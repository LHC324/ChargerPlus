C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE CHARGER
OBJECT MODULE PLACED IN .\Objects\charger.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Src\charger.c LARGE OPTIMIZE(9,SPEED) BROWSE FLOATFUZZY(4) INCDIR(.\Inc)
                    - DEBUG OBJECTEXTEND CODE LISTINCLUDE SYMBOLS PRINT(.\Listings\charger.lst) OBJECT(.\Objects\charger.obj)

line level    source

   1          #include "charger.h"
   1      =1  #ifndef __CHARGER_H
   2      =1  #define __CHARGER_H
   3      =1  
   4      =1  #ifdef __cplusplus
           =1 extern "C" {
           =1 #endif
   7      =1  #include "SC8913.h"
   1      =2  #ifndef __SC8913_H
   2      =2  #define __SC8913_H
   3      =2  
   4      =2  #ifdef __cplusplus
           =2 extern "C" {
           =2 #endif
   7      =2  #include "IIC.h"
   1      =3  #ifndef __I2C_H
   2      =3  #define __I2C_H
   3      =3  
   4      =3  #ifdef __cplusplus
           =3 extern "C" {
           =3 #endif
   7      =3  #include "config.h"
   1      =4  #ifndef __CONFIG_H_
   2      =4  #define __CONFIG_H_
   3      =4  
   4      =4  #include <STC8.H>
   1      =5  #ifndef __STC8F_H_
   2      =5  #define __STC8F_H_
   3      =5  
   4      =5  /////////////////////////////////////////////////
   5      =5  
   6      =5  //包含本头文件后,不用另外再包含"REG51.H"
   7      =5  
   8      =5  //内核特殊功能寄存器
   9      =5  sfr ACC         =   0xe0;
  10      =5  sfr B           =   0xf0;
  11      =5  sfr PSW         =   0xd0;
  12      =5  sbit CY         =   PSW^7;
  13      =5  sbit AC         =   PSW^6;
  14      =5  sbit F0         =   PSW^5;
  15      =5  sbit RS1        =   PSW^4;
  16      =5  sbit RS0        =   PSW^3;
  17      =5  sbit OV         =   PSW^2;
  18      =5  sbit P          =   PSW^0;
  19      =5  sfr SP          =   0x81;
  20      =5  sfr DPL         =   0x82;
  21      =5  sfr DPH         =   0x83;
  22      =5  sfr TA          =   0xae;
  23      =5  sfr DPS         =   0xe3;
  24      =5  sfr DPL1        =   0xe4;
  25      =5  sfr DPH1        =   0xe5;
  26      =5  
  27      =5  
  28      =5  //I/O 口特殊功能寄存器
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 2   

  29      =5  sfr P0          =   0x80;
  30      =5  sfr P1          =   0x90;
  31      =5  sfr P2          =   0xa0;
  32      =5  sfr P3          =   0xb0;
  33      =5  sfr P4          =   0xc0;
  34      =5  sfr P5          =   0xc8;
  35      =5  sfr P6          =   0xe8;
  36      =5  sfr P7          =   0xf8;
  37      =5  sfr P0M0        =   0x94;
  38      =5  sfr P0M1        =   0x93;
  39      =5  sfr P1M0        =   0x92;
  40      =5  sfr P1M1        =   0x91;
  41      =5  sfr P2M0        =   0x96;
  42      =5  sfr P2M1        =   0x95;
  43      =5  sfr P3M0        =   0xb2;
  44      =5  sfr P3M1        =   0xb1;
  45      =5  sfr P4M0        =   0xb4;
  46      =5  sfr P4M1        =   0xb3;
  47      =5  sfr P5M0        =   0xca;
  48      =5  sfr P5M1        =   0xc9;
  49      =5  sfr P6M0        =   0xcc;
  50      =5  sfr P6M1        =   0xcb;
  51      =5  sfr P7M0        =   0xe2;
  52      =5  sfr P7M1        =   0xe1;
  53      =5  
  54      =5  sbit P00        =   P0^0;
  55      =5  sbit P01        =   P0^1;
  56      =5  sbit P02        =   P0^2;
  57      =5  sbit P03        =   P0^3;
  58      =5  sbit P04        =   P0^4;
  59      =5  sbit P05        =   P0^5;
  60      =5  sbit P06        =   P0^6;
  61      =5  sbit P07        =   P0^7;
  62      =5  sbit P10        =   P1^0;
  63      =5  sbit P11        =   P1^1;
  64      =5  sbit P12        =   P1^2;
  65      =5  sbit P13        =   P1^3;
  66      =5  sbit P14        =   P1^4;
  67      =5  sbit P15        =   P1^5;
  68      =5  sbit P16        =   P1^6;
  69      =5  sbit P17        =   P1^7;
  70      =5  sbit P20        =   P2^0;
  71      =5  sbit P21        =   P2^1;
  72      =5  sbit P22        =   P2^2;
  73      =5  sbit P23        =   P2^3;
  74      =5  sbit P24        =   P2^4;
  75      =5  sbit P25        =   P2^5;
  76      =5  sbit P26        =   P2^6;
  77      =5  sbit P27        =   P2^7;
  78      =5  sbit P30        =   P3^0;
  79      =5  sbit P31        =   P3^1;
  80      =5  sbit P32        =   P3^2;
  81      =5  sbit P33        =   P3^3;
  82      =5  sbit P34        =   P3^4;
  83      =5  sbit P35        =   P3^5;
  84      =5  sbit P36        =   P3^6;
  85      =5  sbit P37        =   P3^7;
  86      =5  sbit P40        =   P4^0;
  87      =5  sbit P41        =   P4^1;
  88      =5  sbit P42        =   P4^2;
  89      =5  sbit P43        =   P4^3;
  90      =5  sbit P44        =   P4^4;
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 3   

  91      =5  sbit P45        =   P4^5;
  92      =5  sbit P46        =   P4^6;
  93      =5  sbit P47        =   P4^7;
  94      =5  sbit P50        =   P5^0;
  95      =5  sbit P51        =   P5^1;
  96      =5  sbit P52        =   P5^2;
  97      =5  sbit P53        =   P5^3;
  98      =5  sbit P54        =   P5^4;
  99      =5  sbit P55        =   P5^5;
 100      =5  sbit P56        =   P5^6;
 101      =5  sbit P57        =   P5^7;
 102      =5  sbit P60        =   P6^0;
 103      =5  sbit P61        =   P6^1;
 104      =5  sbit P62        =   P6^2;
 105      =5  sbit P63        =   P6^3;
 106      =5  sbit P64        =   P6^4;
 107      =5  sbit P65        =   P6^5;
 108      =5  sbit P66        =   P6^6;
 109      =5  sbit P67        =   P6^7;
 110      =5  sbit P70        =   P7^0;
 111      =5  sbit P71        =   P7^1;
 112      =5  sbit P72        =   P7^2;
 113      =5  sbit P73        =   P7^3;
 114      =5  sbit P74        =   P7^4;
 115      =5  sbit P75        =   P7^5;
 116      =5  sbit P76        =   P7^6;
 117      =5  sbit P77        =   P7^7;
 118      =5  
 119      =5  //如下特殊功能寄存器位于扩展RAM区域
 120      =5  //访问这些寄存器,需先将P_SW2的BIT7设置为1,才可正常读写
 121      =5  #define P0PU        (*(unsigned char volatile xdata *)0xfe10)
 122      =5  #define P1PU        (*(unsigned char volatile xdata *)0xfe11)
 123      =5  #define P2PU        (*(unsigned char volatile xdata *)0xfe12)
 124      =5  #define P3PU        (*(unsigned char volatile xdata *)0xfe13)
 125      =5  #define P4PU        (*(unsigned char volatile xdata *)0xfe14)
 126      =5  #define P5PU        (*(unsigned char volatile xdata *)0xfe15)
 127      =5  #define P6PU        (*(unsigned char volatile xdata *)0xfe16)
 128      =5  #define P7PU        (*(unsigned char volatile xdata *)0xfe17)
 129      =5  #define P0NCS       (*(unsigned char volatile xdata *)0xfe18)
 130      =5  #define P1NCS       (*(unsigned char volatile xdata *)0xfe19)
 131      =5  #define P2NCS       (*(unsigned char volatile xdata *)0xfe1a)
 132      =5  #define P3NCS       (*(unsigned char volatile xdata *)0xfe1b)
 133      =5  #define P4NCS       (*(unsigned char volatile xdata *)0xfe1c)
 134      =5  #define P5NCS       (*(unsigned char volatile xdata *)0xfe1d)
 135      =5  #define P6NCS       (*(unsigned char volatile xdata *)0xfe1e)
 136      =5  #define P7NCS       (*(unsigned char volatile xdata *)0xfe1f)
 137      =5  
 138      =5  //系统管理特殊功能寄存器
 139      =5  sfr PCON        =   0x87;
 140      =5  #define SMOD        0x80
 141      =5  #define SMOD0       0x40
 142      =5  #define LVDF        0x20
 143      =5  #define POF         0x10
 144      =5  #define GF1         0x08
 145      =5  #define GF0         0x04
 146      =5  #define PD          0x02
 147      =5  #define IDL         0x01
 148      =5  sfr AUXR        =   0x8e;
 149      =5  #define T0x12       0x80
 150      =5  #define T1x12       0x40
 151      =5  #define UART_M0x6   0x20
 152      =5  #define T2R         0x10
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 4   

 153      =5  #define T2_CT       0x08
 154      =5  #define T2x12       0x04
 155      =5  #define EXTRAM      0x02
 156      =5  #define S1ST2       0x01
 157      =5  sfr AUXR2       =   0x97;
 158      =5  #define TXLNRX      0x10
 159      =5  sfr BUS_SPEED   =   0xa1;
 160      =5  sfr P_SW1       =   0xa2;
 161      =5  sfr P_SW2       =   0xba;
 162      =5  #define EAXFR       0x80
 163      =5  sfr VOCTRL      =   0xbb;
 164      =5  sfr RSTCFG      =   0xff;
 165      =5  
 166      =5  //如下特殊功能寄存器位于扩展RAM区域
 167      =5  //访问这些寄存器,需先将P_SW2的BIT7设置为1,才可正常读写
 168      =5  #define CKSEL       (*(unsigned char volatile xdata *)0xfe00)
 169      =5  #define CLKDIV      (*(unsigned char volatile xdata *)0xfe01)
 170      =5  #define IRC24MCR    (*(unsigned char volatile xdata *)0xfe02)
 171      =5  #define XOSCCR      (*(unsigned char volatile xdata *)0xfe03)
 172      =5  #define IRC32KCR    (*(unsigned char volatile xdata *)0xfe04)
 173      =5  
 174      =5  //中断特殊功能寄存器
 175      =5  sfr IE          =   0xa8;
 176      =5  sbit EA         =   IE^7;
 177      =5  sbit ELVD       =   IE^6;
 178      =5  sbit EADC       =   IE^5;
 179      =5  sbit ES         =   IE^4;
 180      =5  sbit ET1        =   IE^3;
 181      =5  sbit EX1        =   IE^2;
 182      =5  sbit ET0        =   IE^1;
 183      =5  sbit EX0        =   IE^0;
 184      =5  sfr IE2         =   0xaf;
 185      =5  #define ET4         0x40
 186      =5  #define ET3         0x20
 187      =5  #define ES4         0x10
 188      =5  #define ES3         0x08
 189      =5  #define ET2         0x04
 190      =5  #define ESPI        0x02
 191      =5  #define ES2         0x01
 192      =5  sfr IP          =   0xb8;
 193      =5  sbit PPCA       =   IP^7;
 194      =5  sbit PLVD       =   IP^6;
 195      =5  sbit PADC       =   IP^5;
 196      =5  sbit PS         =   IP^4;
 197      =5  sbit PT1        =   IP^3;
 198      =5  sbit PX1        =   IP^2;
 199      =5  sbit PT0        =   IP^1;
 200      =5  sbit PX0        =   IP^0;
 201      =5  sfr IP2         =   0xb5;
 202      =5  #define PI2C        0x40
 203      =5  #define PCMP        0x20
 204      =5  #define PX4         0x10
 205      =5  #define PPWMFD      0x08
 206      =5  #define PPWM        0x04
 207      =5  #define PSPI        0x02
 208      =5  #define PS2         0x01
 209      =5  sfr IPH         =   0xb7;
 210      =5  #define PPCAH       0x80
 211      =5  #define PLVDH       0x40
 212      =5  #define PADCH       0x20
 213      =5  #define PSH         0x10
 214      =5  #define PT1H        0x08
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 5   

 215      =5  #define PX1H        0x04
 216      =5  #define PT0H        0x02
 217      =5  #define PX0H        0x01
 218      =5  sfr IP2H        =   0xb6;
 219      =5  #define PI2CH       0x40
 220      =5  #define PCMPH       0x20
 221      =5  #define PX4H        0x10
 222      =5  #define PPWMFDH     0x08
 223      =5  #define PPWMH       0x04
 224      =5  #define PSPIH       0x02
 225      =5  #define PS2H        0x01
 226      =5  sfr INTCLKO     =   0x8f;
 227      =5  #define EX4         0x40
 228      =5  #define EX3         0x20
 229      =5  #define EX2         0x10
 230      =5  #define T2CLKO      0x04
 231      =5  #define T1CLKO      0x02
 232      =5  #define T0CLKO      0x01
 233      =5  sfr AUXINTIF    =   0xef;
 234      =5  #define INT4IF      0x40
 235      =5  #define INT3IF      0x20
 236      =5  #define INT2IF      0x10
 237      =5  #define T4IF        0x04
 238      =5  #define T3IF        0x02
 239      =5  #define T2IF        0x01
 240      =5  
 241      =5  //定时器特殊功能寄存器
 242      =5  sfr TCON        =   0x88;
 243      =5  sbit TF1        =   TCON^7;
 244      =5  sbit TR1        =   TCON^6;
 245      =5  sbit TF0        =   TCON^5;
 246      =5  sbit TR0        =   TCON^4;
 247      =5  sbit IE1        =   TCON^3;
 248      =5  sbit IT1        =   TCON^2;
 249      =5  sbit IE0        =   TCON^1;
 250      =5  sbit IT0        =   TCON^0;
 251      =5  sfr TMOD        =   0x89;
 252      =5  #define T1_GATE     0x80
 253      =5  #define T1_CT       0x40
 254      =5  #define T1_M1       0x20
 255      =5  #define T1_M0       0x10
 256      =5  #define T0_GATE     0x08
 257      =5  #define T0_CT       0x04
 258      =5  #define T0_M1       0x02
 259      =5  #define T0_M0       0x01
 260      =5  sfr TL0         =   0x8a;
 261      =5  sfr TL1         =   0x8b;
 262      =5  sfr TH0         =   0x8c;
 263      =5  sfr TH1         =   0x8d;
 264      =5  sfr T4T3M       =   0xd1;
 265      =5  #define T4R         0x80
 266      =5  #define T4_CT       0x40
 267      =5  #define T4x12       0x20
 268      =5  #define T4CLKO      0x10
 269      =5  #define T3R         0x08
 270      =5  #define T3_CT       0x04
 271      =5  #define T3x12       0x02
 272      =5  #define T3CLKO      0x01
 273      =5  sfr T4H         =   0xd2;
 274      =5  sfr T4L         =   0xd3;
 275      =5  sfr T3H         =   0xd4;
 276      =5  sfr T3L         =   0xd5;
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 6   

 277      =5  sfr T2H         =   0xd6;
 278      =5  sfr T2L         =   0xd7;
 279      =5  sfr TH4         =   0xd2;
 280      =5  sfr TL4         =   0xd3;
 281      =5  sfr TH3         =   0xd4;
 282      =5  sfr TL3         =   0xd5;
 283      =5  sfr TH2         =   0xd6;
 284      =5  sfr TL2         =   0xd7;
 285      =5  sfr WKTCL       =   0xaa;
 286      =5  sfr WKTCH       =   0xab;
 287      =5  #define WKTEN       0x80
 288      =5  sfr WDT_CONTR   =   0xc1;
 289      =5  #define WDT_FLAG    0x80
 290      =5  #define EN_WDT      0x20
 291      =5  #define CLR_WDT     0x10
 292      =5  #define IDL_WDT     0x08
 293      =5  
 294      =5  //串行口特殊功能寄存器
 295      =5  sfr SCON        =   0x98;
 296      =5  sbit SM0        =   SCON^7;
 297      =5  sbit SM1        =   SCON^6;
 298      =5  sbit SM2        =   SCON^5;
 299      =5  sbit REN        =   SCON^4;
 300      =5  sbit TB8        =   SCON^3;
 301      =5  sbit RB8        =   SCON^2;
 302      =5  sbit TI         =   SCON^1;
 303      =5  sbit RI         =   SCON^0;
 304      =5  sfr SBUF        =   0x99;
 305      =5  sfr S2CON       =   0x9a;
 306      =5  #define S2SM0       0x80
 307      =5  #define S2ST4       0x40
 308      =5  #define S2SM2       0x20
 309      =5  #define S2REN       0x10
 310      =5  #define S2TB8       0x08
 311      =5  #define S2RB8       0x04
 312      =5  #define S2TI        0x02
 313      =5  #define S2RI        0x01
 314      =5  sfr S2BUF       =   0x9b;
 315      =5  sfr S3CON       =   0xac;
 316      =5  #define S3SM0       0x80
 317      =5  #define S3ST4       0x40
 318      =5  #define S3SM2       0x20
 319      =5  #define S3REN       0x10
 320      =5  #define S3TB8       0x08
 321      =5  #define S3RB8       0x04
 322      =5  #define S3TI        0x02
 323      =5  #define S3RI        0x01
 324      =5  sfr S3BUF       =   0xad;
 325      =5  sfr S4CON       =   0x84;
 326      =5  #define S4SM0       0x80
 327      =5  #define S4ST4       0x40
 328      =5  #define S4SM2       0x20
 329      =5  #define S4REN       0x10
 330      =5  #define S4TB8       0x08
 331      =5  #define S4RB8       0x04
 332      =5  #define S4TI        0x02
 333      =5  #define S4RI        0x01
 334      =5  sfr S4BUF       =   0x85;
 335      =5  sfr SADDR       =   0xa9;
 336      =5  sfr SADEN       =   0xb9;
 337      =5  
 338      =5  //ADC 特殊功能寄存器
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 7   

 339      =5  sfr ADC_CONTR   =   0xbc;
 340      =5  #define ADC_POWER   0x80
 341      =5  #define ADC_START   0x40
 342      =5  #define ADC_FLAG    0x20
 343      =5  sfr ADC_RES     =   0xbd;
 344      =5  sfr ADC_RESL    =   0xbe;
 345      =5  sfr ADCCFG      =   0xde;
 346      =5  #define ADC_RESFMT  0x20
 347      =5  
 348      =5  //SPI 特殊功能寄存器
 349      =5  sfr SPSTAT      =   0xcd;
 350      =5  #define SPIF        0x80
 351      =5  #define WCOL        0x40
 352      =5  sfr SPCTL       =   0xce;
 353      =5  #define SSIG        0x80
 354      =5  #define SPEN        0x40
 355      =5  #define DORD        0x20
 356      =5  #define MSTR        0x10
 357      =5  #define CPOL        0x08
 358      =5  #define CPHA        0x04
 359      =5  sfr SPDAT       =   0xcf;
 360      =5  
 361      =5  //IAP/ISP 特殊功能寄存器
 362      =5  sfr IAP_DATA    =   0xc2;
 363      =5  sfr IAP_ADDRH   =   0xc3;
 364      =5  sfr IAP_ADDRL   =   0xc4;
 365      =5  sfr IAP_CMD     =   0xc5;
 366      =5  #define IAP_IDL     0x00
 367      =5  #define IAP_READ    0x01
 368      =5  #define IAP_WRITE   0x02
 369      =5  #define IAP_ERASE   0x03
 370      =5  sfr IAP_TRIG    =   0xc6;
 371      =5  sfr IAP_CONTR   =   0xc7;
 372      =5  #define IAPEN       0x80
 373      =5  #define SWBS        0x40
 374      =5  #define SWRST       0x20
 375      =5  #define CMD_FAIL    0x10
 376      =5  sfr ISP_DATA    =   0xc2;
 377      =5  sfr ISP_ADDRH   =   0xc3;
 378      =5  sfr ISP_ADDRL   =   0xc4;
 379      =5  sfr ISP_CMD     =   0xc5;
 380      =5  sfr ISP_TRIG    =   0xc6;
 381      =5  sfr ISP_CONTR   =   0xc7;
 382      =5  
 383      =5  //比较器特殊功能寄存器
 384      =5  sfr CMPCR1      =   0xe6;
 385      =5  #define CMPEN       0x80
 386      =5  #define CMPIF       0x40
 387      =5  #define PIE         0x20
 388      =5  #define NIE         0x10
 389      =5  #define PIS         0x08
 390      =5  #define NIS         0x04
 391      =5  #define CMPOE       0x02
 392      =5  #define CMPRES      0x01
 393      =5  sfr CMPCR2      =   0xe7;
 394      =5  #define INVCMPO     0x80
 395      =5  #define DISFLT      0x40
 396      =5  
 397      =5  //PCA/PWM 特殊功能寄存器
 398      =5  sfr CCON        =   0xd8;
 399      =5  sbit CF         =   CCON^7;
 400      =5  sbit CR         =   CCON^6;
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 8   

 401      =5  sbit CCF3       =   CCON^3;
 402      =5  sbit CCF2       =   CCON^2;
 403      =5  sbit CCF1       =   CCON^1;
 404      =5  sbit CCF0       =   CCON^0;
 405      =5  sfr CMOD        =   0xd9;
 406      =5  #define CIDL        0x80
 407      =5  #define ECF         0x01
 408      =5  sfr CL          =   0xe9;
 409      =5  sfr CH          =   0xf9;
 410      =5  sfr CCAPM0      =   0xda;
 411      =5  #define ECOM0       0x40
 412      =5  #define CCAPP0      0x20
 413      =5  #define CCAPN0      0x10
 414      =5  #define MAT0        0x08
 415      =5  #define TOG0        0x04
 416      =5  #define PWM0        0x02
 417      =5  #define ECCF0       0x01
 418      =5  sfr CCAPM1      =   0xdb;
 419      =5  #define ECOM1       0x40
 420      =5  #define CCAPP1      0x20
 421      =5  #define CCAPN1      0x10
 422      =5  #define MAT1        0x08
 423      =5  #define TOG1        0x04
 424      =5  #define PWM1        0x02
 425      =5  #define ECCF1       0x01
 426      =5  sfr CCAPM2      =   0xdc;
 427      =5  #define ECOM2       0x40
 428      =5  #define CCAPP2      0x20
 429      =5  #define CCAPN2      0x10
 430      =5  #define MAT2        0x08
 431      =5  #define TOG2        0x04
 432      =5  #define PWM2        0x02
 433      =5  #define ECCF2       0x01
 434      =5  sfr CCAPM3      =   0xdd;
 435      =5  #define ECOM3       0x40
 436      =5  #define CCAPP3      0x20
 437      =5  #define CCAPN3      0x10
 438      =5  #define MAT3        0x08
 439      =5  #define TOG3        0x04
 440      =5  #define PWM3        0x02
 441      =5  #define ECCF3       0x01
 442      =5  sfr CCAP0L      =   0xea;
 443      =5  sfr CCAP1L      =   0xeb;
 444      =5  sfr CCAP2L      =   0xec;
 445      =5  sfr CCAP3L      =   0xed;
 446      =5  sfr CCAP0H      =   0xfa;
 447      =5  sfr CCAP1H      =   0xfb;
 448      =5  sfr CCAP2H      =   0xfc;
 449      =5  sfr CCAP3H      =   0xfd;
 450      =5  sfr PCA_PWM0    =   0xf2;
 451      =5  sfr PCA_PWM1    =   0xf3;
 452      =5  sfr PCA_PWM2    =   0xf4;
 453      =5  sfr PCA_PWM3    =   0xf5;
 454      =5  
 455      =5  //增强型PWM波形发生器特殊功能寄存器
 456      =5  sfr PWMCFG      =   0xf1;
 457      =5  #define CBIF        0x80
 458      =5  #define ETADC       0x40
 459      =5  sfr PWMIF       =   0xf6;
 460      =5  #define C7IF        0x80
 461      =5  #define C6IF        0x40
 462      =5  #define C5IF        0x20
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 9   

 463      =5  #define C4IF        0x10
 464      =5  #define C3IF        0x08
 465      =5  #define C2IF        0x04
 466      =5  #define C1IF        0x02
 467      =5  #define C0IF        0x01
 468      =5  sfr PWMFDCR     =   0xf7;
 469      =5  #define INVCMP      0x80
 470      =5  #define INVIO       0x40
 471      =5  #define ENFD        0x20
 472      =5  #define FLTFLIO     0x10
 473      =5  #define EFDI        0x08
 474      =5  #define FDCMP       0x04
 475      =5  #define FDIO        0x02
 476      =5  #define FDIF        0x01
 477      =5  sfr PWMCR       =   0xfe;
 478      =5  #define ENPWM       0x80
 479      =5  #define ECBI        0x40
 480      =5  
 481      =5  //如下特殊功能寄存器位于扩展RAM区域
 482      =5  //访问这些寄存器,需先将P_SW2的BIT7设置为1,才可正常读写
 483      =5  #define PWMC        (*(unsigned int  volatile xdata *)0xfff0)
 484      =5  #define PWMCH       (*(unsigned char volatile xdata *)0xfff0)
 485      =5  #define PWMCL       (*(unsigned char volatile xdata *)0xfff1)
 486      =5  #define PWMCKS      (*(unsigned char volatile xdata *)0xfff2)
 487      =5  #define TADCP       (*(unsigned char volatile xdata *)0xfff3)
 488      =5  #define TADCPH      (*(unsigned char volatile xdata *)0xfff3)
 489      =5  #define TADCPL      (*(unsigned char volatile xdata *)0xfff4)
 490      =5  #define PWM0T1      (*(unsigned int  volatile xdata *)0xff00)
 491      =5  #define PWM0T1H     (*(unsigned char volatile xdata *)0xff00)
 492      =5  #define PWM0T1L     (*(unsigned char volatile xdata *)0xff01)
 493      =5  #define PWM0T2      (*(unsigned int  volatile xdata *)0xff02)
 494      =5  #define PWM0T2H     (*(unsigned char volatile xdata *)0xff02)
 495      =5  #define PWM0T2L     (*(unsigned char volatile xdata *)0xff03)
 496      =5  #define PWM0CR      (*(unsigned char volatile xdata *)0xff04)
 497      =5  #define PWM0HLD     (*(unsigned char volatile xdata *)0xff05)
 498      =5  #define PWM1T1      (*(unsigned int  volatile xdata *)0xff10)
 499      =5  #define PWM1T1H     (*(unsigned char volatile xdata *)0xff10)
 500      =5  #define PWM1T1L     (*(unsigned char volatile xdata *)0xff11)
 501      =5  #define PWM1T2      (*(unsigned int  volatile xdata *)0xff12)
 502      =5  #define PWM1T2H     (*(unsigned char volatile xdata *)0xff12)
 503      =5  #define PWM1T2L     (*(unsigned char volatile xdata *)0xff13)
 504      =5  #define PWM1CR      (*(unsigned char volatile xdata *)0xff14)
 505      =5  #define PWM1HLD     (*(unsigned char volatile xdata *)0xff15)
 506      =5  #define PWM2T1      (*(unsigned int  volatile xdata *)0xff20)
 507      =5  #define PWM2T1H     (*(unsigned char volatile xdata *)0xff20)
 508      =5  #define PWM2T1L     (*(unsigned char volatile xdata *)0xff21)
 509      =5  #define PWM2T2      (*(unsigned int  volatile xdata *)0xff22)
 510      =5  #define PWM2T2H     (*(unsigned char volatile xdata *)0xff22)
 511      =5  #define PWM2T2L     (*(unsigned char volatile xdata *)0xff23)
 512      =5  #define PWM2CR      (*(unsigned char volatile xdata *)0xff24)
 513      =5  #define PWM2HLD     (*(unsigned char volatile xdata *)0xff25)
 514      =5  #define PWM3T1      (*(unsigned int  volatile xdata *)0xff30)
 515      =5  #define PWM3T1H     (*(unsigned char volatile xdata *)0xff30)
 516      =5  #define PWM3T1L     (*(unsigned char volatile xdata *)0xff31)
 517      =5  #define PWM3T2      (*(unsigned int  volatile xdata *)0xff32)
 518      =5  #define PWM3T2H     (*(unsigned char volatile xdata *)0xff32)
 519      =5  #define PWM3T2L     (*(unsigned char volatile xdata *)0xff33)
 520      =5  #define PWM3CR      (*(unsigned char volatile xdata *)0xff34)
 521      =5  #define PWM3HLD     (*(unsigned char volatile xdata *)0xff35)
 522      =5  #define PWM4T1      (*(unsigned int  volatile xdata *)0xff40)
 523      =5  #define PWM4T1H     (*(unsigned char volatile xdata *)0xff40)
 524      =5  #define PWM4T1L     (*(unsigned char volatile xdata *)0xff41)
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 10  

 525      =5  #define PWM4T2      (*(unsigned int  volatile xdata *)0xff42)
 526      =5  #define PWM4T2H     (*(unsigned char volatile xdata *)0xff42)
 527      =5  #define PWM4T2L     (*(unsigned char volatile xdata *)0xff43)
 528      =5  #define PWM4CR      (*(unsigned char volatile xdata *)0xff44)
 529      =5  #define PWM4HLD     (*(unsigned char volatile xdata *)0xff45)
 530      =5  #define PWM5T1      (*(unsigned int  volatile xdata *)0xff50)
 531      =5  #define PWM5T1H     (*(unsigned char volatile xdata *)0xff50)
 532      =5  #define PWM5T1L     (*(unsigned char volatile xdata *)0xff51)
 533      =5  #define PWM5T2      (*(unsigned int  volatile xdata *)0xff52)
 534      =5  #define PWM5T2H     (*(unsigned char volatile xdata *)0xff52)
 535      =5  #define PWM5T2L     (*(unsigned char volatile xdata *)0xff53)
 536      =5  #define PWM5CR      (*(unsigned char volatile xdata *)0xff54)
 537      =5  #define PWM5HLD     (*(unsigned char volatile xdata *)0xff55)
 538      =5  #define PWM6T1      (*(unsigned int  volatile xdata *)0xff60)
 539      =5  #define PWM6T1H     (*(unsigned char volatile xdata *)0xff60)
 540      =5  #define PWM6T1L     (*(unsigned char volatile xdata *)0xff61)
 541      =5  #define PWM6T2      (*(unsigned int  volatile xdata *)0xff62)
 542      =5  #define PWM6T2H     (*(unsigned char volatile xdata *)0xff62)
 543      =5  #define PWM6T2L     (*(unsigned char volatile xdata *)0xff63)
 544      =5  #define PWM6CR      (*(unsigned char volatile xdata *)0xff64)
 545      =5  #define PWM6HLD     (*(unsigned char volatile xdata *)0xff65)
 546      =5  #define PWM7T1      (*(unsigned int  volatile xdata *)0xff70)
 547      =5  #define PWM7T1H     (*(unsigned char volatile xdata *)0xff70)
 548      =5  #define PWM7T1L     (*(unsigned char volatile xdata *)0xff71)
 549      =5  #define PWM7T2      (*(unsigned int  volatile xdata *)0xff72)
 550      =5  #define PWM7T2H     (*(unsigned char volatile xdata *)0xff72)
 551      =5  #define PWM7T2L     (*(unsigned char volatile xdata *)0xff73)
 552      =5  #define PWM7CR      (*(unsigned char volatile xdata *)0xff74)
 553      =5  #define PWM7HLD     (*(unsigned char volatile xdata *)0xff75)
 554      =5  
 555      =5  //I2C特殊功能寄存器
 556      =5  //如下特殊功能寄存器位于扩展RAM区域
 557      =5  //访问这些寄存器,需先将P_SW2的BIT7设置为1,才可正常读写
 558      =5  #define I2CCFG      (*(unsigned char volatile xdata *)0xfe80)
 559      =5  #define ENI2C       0x80
 560      =5  #define MSSL        0x40
 561      =5  #define I2CMSCR     (*(unsigned char volatile xdata *)0xfe81)
 562      =5  #define EMSI        0x80
 563      =5  #define I2CMSST     (*(unsigned char volatile xdata *)0xfe82)
 564      =5  #define MSBUSY      0x80
 565      =5  #define MSIF        0x40
 566      =5  #define MSACKI      0x02
 567      =5  #define MSACKO      0x01
 568      =5  #define I2CSLCR     (*(unsigned char volatile xdata *)0xfe83)
 569      =5  #define ESTAI       0x40
 570      =5  #define ERXI        0x20
 571      =5  #define ETXI        0x10
 572      =5  #define ESTOI       0x08
 573      =5  #define SLRST       0x01
 574      =5  #define I2CSLST     (*(unsigned char volatile xdata *)0xfe84)
 575      =5  #define SLBUSY      0x80
 576      =5  #define STAIF       0x40
 577      =5  #define RXIF        0x20
 578      =5  #define TXIF        0x10
 579      =5  #define STOIF       0x08
 580      =5  #define TXING       0x04
 581      =5  #define SLACKI      0x02
 582      =5  #define SLACKO      0x01
 583      =5  #define I2CSLADR    (*(unsigned char volatile xdata *)0xfe85)
 584      =5  #define I2CTXD      (*(unsigned char volatile xdata *)0xfe86)
 585      =5  #define I2CRXD      (*(unsigned char volatile xdata *)0xfe87)
 586      =5  
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 11  

 587      =5  /////////////////////////////////////////////////
 588      =5  
 589      =5  #endif
 590      =5  
   5      =4  #include <stdio.h>
   1      =5  /*--------------------------------------------------------------------------
   2      =5  STDIO.H
   3      =5  
   4      =5  Prototypes for standard I/O functions.
   5      =5  Copyright (c) 1988-2002 Keil Elektronik GmbH and Keil Software, Inc.
   6      =5  All rights reserved.
   7      =5  --------------------------------------------------------------------------*/
   8      =5  
   9      =5  #ifndef __STDIO_H__
  10      =5  #define __STDIO_H__
  11      =5  
  12      =5  #ifndef EOF
  13      =5   #define EOF -1
  14      =5  #endif
  15      =5  
  16      =5  #ifndef NULL
  17      =5   #define NULL ((void *) 0)
  18      =5  #endif
  19      =5  
  20      =5  #ifndef _SIZE_T
  21      =5   #define _SIZE_T
  22      =5   typedef unsigned int size_t;
  23      =5  #endif
  24      =5  
  25      =5  #pragma SAVE
  26      =5  #pragma REGPARMS
  27      =5  extern char _getkey (void);
  28      =5  extern char getchar (void);
  29      =5  extern char ungetchar (char);
  30      =5  extern char putchar (char);
  31      =5  extern int printf   (const char *, ...);
  32      =5  extern int sprintf  (char *, const char *, ...);
  33      =5  extern int vprintf  (const char *, char *);
  34      =5  extern int vsprintf (char *, const char *, char *);
  35      =5  extern char *gets (char *, int n);
  36      =5  extern int scanf (const char *, ...);
  37      =5  extern int sscanf (char *, const char *, ...);
  38      =5  extern int puts (const char *);
  39      =5  
  40      =5  #pragma RESTORE
  41      =5  
  42      =5  #endif
  43      =5  
   6      =4  #include <intrins.h>
   1      =5  /*--------------------------------------------------------------------------
   2      =5  INTRINS.H
   3      =5  
   4      =5  Intrinsic functions for C51.
   5      =5  Copyright (c) 1988-2010 Keil Elektronik GmbH and ARM Germany GmbH
   6      =5  All rights reserved.
   7      =5  --------------------------------------------------------------------------*/
   8      =5  
   9      =5  #ifndef __INTRINS_H__
  10      =5  #define __INTRINS_H__
  11      =5  
  12      =5  #pragma SAVE
  13      =5  
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 12  

  14      =5  #if defined (__CX2__)
           =5 #pragma FUNCTIONS(STATIC)
           =5 /* intrinsic functions are reentrant, but need static attribute */
           =5 #endif
  18      =5  
  19      =5  extern void          _nop_     (void);
  20      =5  extern bit           _testbit_ (bit);
  21      =5  extern unsigned char _cror_    (unsigned char, unsigned char);
  22      =5  extern unsigned int  _iror_    (unsigned int,  unsigned char);
  23      =5  extern unsigned long _lror_    (unsigned long, unsigned char);
  24      =5  extern unsigned char _crol_    (unsigned char, unsigned char);
  25      =5  extern unsigned int  _irol_    (unsigned int,  unsigned char);
  26      =5  extern unsigned long _lrol_    (unsigned long, unsigned char);
  27      =5  extern unsigned char _chkfloat_(float);
  28      =5  #if defined (__CX2__)
           =5 extern int           abs       (int);
           =5 extern void          _illop_   (void);
           =5 #endif
  32      =5  #if !defined (__CX2__)
  33      =5  extern void          _push_    (unsigned char _sfr);
  34      =5  extern void          _pop_     (unsigned char _sfr);
  35      =5  #endif
  36      =5  
  37      =5  #pragma RESTORE
  38      =5  
  39      =5  #endif
  40      =5  
   7      =4  #include <string.h>
   1      =5  /*--------------------------------------------------------------------------
   2      =5  STRING.H
   3      =5  
   4      =5  String functions.
   5      =5  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =5  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =5  All rights reserved.
   8      =5  --------------------------------------------------------------------------*/
   9      =5  
  10      =5  #ifndef __STRING_H__
  11      =5  #define __STRING_H__
  12      =5  
  13      =5  #ifndef _SIZE_T
           =5  #define _SIZE_T
           =5  typedef unsigned int size_t;
           =5 #endif
  17      =5  
  18      =5  #ifndef NULL
           =5  #define NULL ((void *)0)
           =5 #endif
  21      =5  
  22      =5  #pragma SAVE
  23      =5  #pragma REGPARMS
  24      =5  extern char  *strcat  (char *s1, const char *s2);
  25      =5  extern char  *strncat (char *s1, const char *s2, size_t n);
  26      =5  
  27      =5  extern char   strcmp  (const char *s1, const char *s2);
  28      =5  extern char   strncmp (const char *s1, const char *s2, size_t n);
  29      =5  
  30      =5  extern char  *strcpy  (char *s1, const char *s2);
  31      =5  extern char  *strncpy (char *s1, const char *s2, size_t n);
  32      =5  
  33      =5  extern size_t strlen  (const char *);
  34      =5  
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 13  

  35      =5  extern char  *strchr  (const char *s, char c);
  36      =5  extern int    strpos  (const char *s, char c);
  37      =5  extern char  *strrchr (const char *s, char c);
  38      =5  extern int    strrpos (const char *s, char c);
  39      =5  
  40      =5  extern size_t strspn  (const char *s, const char *set);
  41      =5  extern size_t strcspn (const char *s, const char *set);
  42      =5  extern char  *strpbrk (const char *s, const char *set);
  43      =5  extern char  *strrpbrk(const char *s, const char *set);
  44      =5  extern char  *strstr  (const char *s, const char *sub);
  45      =5  extern char  *strtok  (char *str, const char *set);
  46      =5  
  47      =5  extern char   memcmp  (const void *s1, const void *s2, size_t n);
  48      =5  extern void  *memcpy  (void *s1, const void *s2, size_t n);
  49      =5  extern void  *memchr  (const void *s, char val, size_t n);
  50      =5  extern void  *memccpy (void *s1, const void *s2, char val, size_t n);
  51      =5  extern void  *memmove (void *s1, const void *s2, size_t n);
  52      =5  extern void  *memset  (void *s, char val, size_t n);
  53      =5  #pragma RESTORE
  54      =5  
  55      =5  #endif
   8      =4  #include <stdlib.h>
   1      =5  /*--------------------------------------------------------------------------
   2      =5  STDLIB.H
   3      =5  
   4      =5  Standard functions.
   5      =5  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =5  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =5  All rights reserved.
   8      =5  --------------------------------------------------------------------------*/
   9      =5  
  10      =5  #ifndef __STDLIB_H__
  11      =5  #define __STDLIB_H__
  12      =5  
  13      =5  #ifndef _SIZE_T
           =5  #define _SIZE_T
           =5  typedef unsigned int size_t;
           =5 #endif
  17      =5  
  18      =5  #ifndef NULL
           =5  #define NULL ((void *)0)
           =5 #endif
  21      =5  
  22      =5  #ifndef _WCHAR_T_DEFINED_
  23      =5  #define _WCHAR_T_DEFINED_
  24      =5  typedef char wchar_t;
  25      =5  #endif
  26      =5  
  27      =5  #if defined (__CX2__)
           =5 #ifndef _DIV_T_DEFINED
           =5 typedef struct _div_t {
           =5         int quot;
           =5         int rem;
           =5 } div_t;
           =5 typedef struct _ldiv_t {
           =5         long quot;
           =5         long rem;
           =5 } ldiv_t;
           =5 #define _DIV_T_DEFINED
           =5 #endif // _DIV_T_DEFINED
           =5 #endif // __CX2__
  40      =5  
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 14  

  41      =5  #ifndef RAND_MAX
  42      =5   #define RAND_MAX  32767u
  43      =5  #endif
  44      =5  
  45      =5  #if defined (__CX2__)
           =5 #pragma SAVE
           =5 #pragma FUNCTIONS(STATIC)
           =5 /* intrinsic functions are reentrant, but need static attribute */
           =5 extern int    abs  (int   val);
           =5 #pragma RESTORE
           =5 #endif // __CX2__
  52      =5  
  53      =5  #pragma SAVE
  54      =5  #pragma REGPARMS
  55      =5  
  56      =5  extern char   cabs (char  val);
  57      =5  #if !defined (__CX2__)
  58      =5  extern int    abs  (int   val);
  59      =5  #endif // __CX2__
  60      =5  extern long   labs (long  val);
  61      =5  
  62      =5  extern float  atof (const char *s1);
  63      =5  extern long   atol (const char *s1);
  64      =5  extern int    atoi (const char *s1);
  65      =5  extern int    rand (void);
  66      =5  extern void   srand (unsigned int seed);
  67      =5  
  68      =5  #ifdef _DIV_T_DEFINED
           =5 extern div_t  __div (int numer, int denom);
           =5 #define div(numer,denom)  __div((numer),(denom));
           =5 extern ldiv_t ldiv (long numer, long denom);
           =5 #endif // _DIV_T_DEFINED
  73      =5  
  74      =5  extern float         strtod  (const char *nptr, char **endptr);
  75      =5  extern long          strtol  (const char *nptr, char **endptr, unsigned char base);
  76      =5  extern unsigned long strtoul (const char *nptr, char **endptr, unsigned char base);
  77      =5  
  78      =5  #define _MALLOC_MEM_    xdata
  79      =5  
  80      =5  extern void init_mempool          (void _MALLOC_MEM_ *p, size_t size);
  81      =5  extern void _MALLOC_MEM_ *malloc  (size_t size);
  82      =5  extern void free                  (void _MALLOC_MEM_ *p);
  83      =5  extern void _MALLOC_MEM_ *realloc (void _MALLOC_MEM_ *p, size_t size);
  84      =5  extern void _MALLOC_MEM_ *calloc  (size_t nmemb, size_t size);
  85      =5  
  86      =5  #if defined (__CX2__)
           =5 extern void abort(void);
           =5 #endif // __CX2__
  89      =5  
  90      =5  #pragma RESTORE
  91      =5  
  92      =5  #endif // __STDLIB_H__
   9      =4  #include <string.h>
   1      =5  /*--------------------------------------------------------------------------
   2      =5  STRING.H
   3      =5  
   4      =5  String functions.
   5      =5  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =5  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =5  All rights reserved.
   8      =5  --------------------------------------------------------------------------*/
   9      =5  
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 15  

  10      =5  #ifndef __STRING_H__
           =5 #define __STRING_H__
           =5 
           =5 #ifndef _SIZE_T
           =5  #define _SIZE_T
           =5  typedef unsigned int size_t;
           =5 #endif
           =5 
           =5 #ifndef NULL
           =5  #define NULL ((void *)0)
           =5 #endif
           =5 
           =5 #pragma SAVE
           =5 #pragma REGPARMS
           =5 extern char  *strcat  (char *s1, const char *s2);
           =5 extern char  *strncat (char *s1, const char *s2, size_t n);
           =5 
           =5 extern char   strcmp  (const char *s1, const char *s2);
           =5 extern char   strncmp (const char *s1, const char *s2, size_t n);
           =5 
           =5 extern char  *strcpy  (char *s1, const char *s2);
           =5 extern char  *strncpy (char *s1, const char *s2, size_t n);
           =5 
           =5 extern size_t strlen  (const char *);
           =5 
           =5 extern char  *strchr  (const char *s, char c);
           =5 extern int    strpos  (const char *s, char c);
           =5 extern char  *strrchr (const char *s, char c);
           =5 extern int    strrpos (const char *s, char c);
           =5 
           =5 extern size_t strspn  (const char *s, const char *set);
           =5 extern size_t strcspn (const char *s, const char *set);
           =5 extern char  *strpbrk (const char *s, const char *set);
           =5 extern char  *strrpbrk(const char *s, const char *set);
           =5 extern char  *strstr  (const char *s, const char *sub);
           =5 extern char  *strtok  (char *str, const char *set);
           =5 
           =5 extern char   memcmp  (const void *s1, const void *s2, size_t n);
           =5 extern void  *memcpy  (void *s1, const void *s2, size_t n);
           =5 extern void  *memchr  (const void *s, char val, size_t n);
           =5 extern void  *memccpy (void *s1, const void *s2, char val, size_t n);
           =5 extern void  *memmove (void *s1, const void *s2, size_t n);
           =5 extern void  *memset  (void *s, char val, size_t n);
           =5 #pragma RESTORE
           =5 
           =5 #endif
  10      =4  #include <absacc.h> //可直接操作内存地址
   1      =5  /*--------------------------------------------------------------------------
   2      =5  ABSACC.H
   3      =5  
   4      =5  Direct access to 8051, extended 8051 and NXP 8051MX memory areas.
   5      =5  Copyright (c) 1988-2010 Keil Elektronik GmbH and ARM Germany GmbH
   6      =5  All rights reserved.
   7      =5  --------------------------------------------------------------------------*/
   8      =5  
   9      =5  #ifndef __ABSACC_H__
  10      =5  #define __ABSACC_H__
  11      =5  
  12      =5  #define CBYTE ((unsigned char volatile code  *) 0)
  13      =5  #define DBYTE ((unsigned char volatile data  *) 0)
  14      =5  #if !defined (__CX2__)
  15      =5  #define PBYTE ((unsigned char volatile pdata *) 0)
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 16  

  16      =5  #endif
  17      =5  #define XBYTE ((unsigned char volatile xdata *) 0)
  18      =5  
  19      =5  #define CWORD ((unsigned int volatile code  *) 0)
  20      =5  #define DWORD ((unsigned int volatile data  *) 0)
  21      =5  #if !defined (__CX2__)
  22      =5  #define PWORD ((unsigned int volatile pdata *) 0)
  23      =5  #endif
  24      =5  #define XWORD ((unsigned int volatile xdata *) 0)
  25      =5  
  26      =5  
  27      =5  #if defined (__CX51__) || defined (__CX2__)
           =5 #define FVAR(object, addr)   (*((object volatile far *) (addr)))
           =5 #define FARRAY(object, base) ((object volatile far *) (base))
           =5 #define FCVAR(object, addr)   (*((object const far *) (addr)))
           =5 #define FCARRAY(object, base) ((object const far *) (base))
           =5 #else
  33      =5  #define FVAR(object, addr)    (*((object volatile far *) ((addr)+0x10000L)))
  34      =5  #define FCVAR(object, addr)   (*((object const far *) ((addr)+0x810000L)))
  35      =5  #define FARRAY(object, base)  ((object volatile far *) ((base)+0x10000L))
  36      =5  #define FCARRAY(object, base) ((object const far *) ((base)+0x810000L))
  37      =5  #endif
  38      =5  
  39      =5  #if defined (__CX2__)
           =5 #define HBYTE ((unsigned char volatile huge *)  0)
           =5 #define HWORD ((unsigned int volatile huge *)  0)
           =5 #define HVAR(object, addr)   (*((object volatile huge *) (addr)))
           =5 #define HARRAY(object, base) ((object volatile huge *) (base))
           =5 #endif
  45      =5  
  46      =5  #define CVAR(object, addr)   (*((object volatile code *) (addr)))
  47      =5  #define CARRAY(object, base) ((object volatile code *) (base))
  48      =5  #define DVAR(object, addr)   (*((object volatile data *) (addr)))
  49      =5  #define DARRAY(object, base) ((object volatile data *) (base))
  50      =5  #define XVAR(object, addr)   (*((object volatile xdata *) (addr)))
  51      =5  #define XARRAY(object, base) ((object volatile xdata *) (base))
  52      =5  
  53      =5  #endif
  11      =4  #include <stdarg.h>
   1      =5  /*--------------------------------------------------------------------------
   2      =5  STDARG.H
   3      =5  
   4      =5  Prototypes for variable argument lists.
   5      =5  Copyright (c) 1988-2008 Keil Elektronik GmbH and Keil Software, Inc.
   6      =5  Copyright (c) 2008-2016 ARM Germany GmbH
   7      =5  All rights reserved.
   8      =5  --------------------------------------------------------------------------*/
   9      =5  
  10      =5  #ifndef __STDARG_H__
  11      =5  #define __STDARG_H__
  12      =5  
  13      =5  #ifndef __CX2__
  14      =5  #ifndef NULL
           =5  #define NULL ((void *)0)
           =5 #endif
  17      =5  #endif
  18      =5  
  19      =5  #ifndef _VA_LIST_DEFINED
  20      =5  typedef char *va_list;
  21      =5  #define _VA_LIST_DEFINED
  22      =5  #endif
  23      =5  
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 17  

  24      =5  #if defined __CX2__ && __CX2__ >= 558
           =5   #define va_start(ap,v) ap = _va_start_ (&v, sizeof(v))
           =5   extern void *_va_start_ (void *ap, int sz);   // intrinsic
           =5 #else
  28      =5    #define va_start(ap,v) ap = (va_list)&v + sizeof(v)
  29      =5  #endif
  30      =5  
  31      =5  #define va_arg(ap,t) (((t *)ap)++[0])
  32      =5  #define va_end(ap)   (ap = (va_list)0)
  33      =5  
  34      =5  #endif
  12      =4  
  13      =4  
  14      =4  /**********************布尔变量定义**********************/
  15      =4  #define true  1
  16      =4  #define false 0
  17      =4  /**********************布尔变量定义**********************/
  18      =4  
  19      =4  /***********************************API配置接口***********************************/
  20      =4  /*使用外部晶振*/
  21      =4  #define EXTERNAL_CRYSTAL 0 
  22      =4  /*调试是否启用串口*/
  23      =4  #define USE_PRINTF_DEBUG 0 
  24      =4  /*调试选项*/
  25      =4  #define DEBUGGING    0
  26      =4  /*迪文屏幕使用CRC校验*/
  27      =4  #define USING_CRC 1
  28      =4  /*定义WIFI模块相关引脚*/
  29      =4  #define WIFI_RESET              P23
  30      =4  #define WIFI_RELOAD             P20
  31      =4  
  32      =4  #define COUNTMAX     65536U
  33      =4  
  34      =4  /*消除编译器未使用变量警告*/
  35      =4  #define UNUSED_VARIABLE(x)      ((void)(x))
  36      =4  #define UNUSED_PARAMETER(x) UNUSED_VARIABLE(x)
  37      =4  
  38      =4  //(1/FOSC)*count =times(us)->count = time*FOSC/1000(ms)
  39      =4  #define FOSC         27000000UL//11059200UL
  40      =4  /*1ms(时钟频率越高，所能产生的时间越小)*/  
  41      =4  #define TIMES        10U  
  42      =4  /*定时器模式选择*/
  43      =4  #define TIMER_MODE   12U
  44      =4  /*定时器分频系数，默认为一分频*/  
  45      =4  #define TIME_DIV     1U  
  46      =4  #define T12_MODE (TIMES * FOSC / 1000 / 12 / TIME_DIV) 
  47      =4  #define T1_MODE  (TIMES * FOSC/ 1000 / TIME_DIV)
  48      =4  #define TIMERS_OVERFLOW (COUNTMAX * 1000 * TIMER_MODE * TIME_DIV) / FOSC
  49      =4  
  50      =4  #define OPEN_GLOBAL_OUTAGE()  (EA = 1 << 0)
  51      =4  #define CLOSE_GLOBAL_OUTAGE() (EA = 0 << 0)
  52      =4  /*判断延时数是否超出硬件允许范围*/
  53      =4  #if(TIMES > TIMERS_OVERFLOW)
           =4 #error The timer cannot generate the current duration!
           =4 #endif
  56      =4  /***********************************API配置接口***********************************/
  57      =4  
  58      =4  /***********************************常用的数据类型***********************************/
  59      =4  typedef unsigned char  uint8_t;
  60      =4  typedef signed char    int8_t;
  61      =4  typedef unsigned short int  uint16_t;
  62      =4  typedef unsigned long  uint32_t;
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 18  

  63      =4  typedef signed long    int32_t;
  64      =4  typedef volatile       __IO;   
  65      =4  
  66      =4  /***********************************常用的数据类型***********************************/
  67      =4  
  68      =4  /***********************************系统上电参数***********************************/
  69      =4  #define DEFAULT_SYSTEM_PARAMETER  "\xFF\xFF\xFF\xFF\x02\x01\x00\x84\x50"
  70      =4  
  71      =4  /***********************************系统上电参数***********************************/
  72      =4  
  73      =4  /***********************************结构体的妙用 ***********************************/
  74      =4  /*获得结构体(TYPE)的变量成员(MEMBER)在此结构体中的偏移量*/ 
  75      =4  #define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
  76      =4  /*根据"结构体(type)变量"中的"域成员变量(member)的指针(ptr)"来获取指向整个结构体
             -变量的指针*/ 
  77      =4  #define container_of(ptr, type, member) ({ \
  78      =4          const typeof( ((type *)0)->member ) *__mptr = (ptr); \
  79      =4          (type *)( (char *)__mptr - offsetof(type,member) );}) 
  80      =4  /***********************************结构体的妙用 ***********************************/
  81      =4  
  82      =4  
  83      =4  extern const uint8_t g_TimerNumbers;
  84      =4  /***********************************函数声明***********************************/
  85      =4  void  Gpio_Init(void);
  86      =4  /***********************************函数声明***********************************/
  87      =4  #endif
   8      =3  
   9      =3  /*延时的个数，5即为延时5Us*/
  10      =3  #define IIC_DELAY 5U
  11      =3  
  12      =3  #define I2C_Fail    0U
  13      =3  #define I2C_Succeed 1U
  14      =3  
  15      =3  /*定义SCL输出的宏定义*/
  16      =3  sbit SCL_CHANNEL0 = P0^0;
  17      =3  sbit SCL_CHANNEL1 = P1^2;
  18      =3  sbit SCL_CHANNEL2 = P4^4;
  19      =3  /*定义SDA输出、读取的宏定义*/
  20      =3  sbit SDA_CHANNEL0 = P2^7;
  21      =3  sbit SDA_CHANNEL1 = P0^5;
  22      =3  sbit SDA_CHANNEL2 = P1^4;
  23      =3  
  24      =3  #define SDA_READ_CHANNELX(CH) \
  25      =3  (CH == Channel0 ? SDA_CHANNEL0 : (CH == Channel1) ? SDA_CHANNEL1 : SDA_CHANNEL2)
  26      =3  
  27      =3  /*IIC层封装*/
  28      =3  typedef enum 
  29      =3  {
  30      =3      Channel0 = 0x00,
  31      =3      Channel1,
  32      =3      Channel2
  33      =3  }IIC_Channel;
  34      =3  
  35      =3  typedef enum 
  36      =3  {
  37      =3      Low  = 0x00,
  38      =3      High = !Low,
  39      =3  }IIC_Pin_State;
  40      =3  
  41      =3  
  42      =3  extern void Delay_Us(uint16_t us);              //@11.0592MHz
  43      =3  extern void Delay_Ms(uint16_t ms);              //@11.0592MHz
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 19  

  44      =3  void Delay_5Us(void);           //@27MHz
  45      =3  
  46      =3  
  47      =3  extern void I2C_Start(IIC_Channel channel); 
  48      =3  extern void I2C_Stop(IIC_Channel channel);
  49      =3  extern void I2C_SendByte(IIC_Channel channel, uint8_t sendByte);
  50      =3  extern uint8_t I2C_WaitAck(IIC_Channel channel, uint16_t timeout);
  51      =3  extern void I2C_SendAck(IIC_Channel channel);
  52      =3  extern void I2C_SendNAck(IIC_Channel channel);
  53      =3  extern uint8_t I2C_ReadByte(IIC_Channel channel); 
  54      =3  extern uint8_t I2C_Set_SCL(IIC_Channel channel, IIC_Pin_State sate); 
  55      =3  extern uint8_t I2C_Set_SDA(IIC_Channel channel, IIC_Pin_State sate); 
  56      =3  
  57      =3  #ifdef __cplusplus
           =3 }
           =3 #endif
  60      =3  
  61      =3  #endif /* __I2C_H */
   8      =2  
   9      =2  /*是否启用外部中断信号检测引脚*/
  10      =2  #define USING_INT_PIN 0
  11      =2  /*是否启用快速充电引脚*/
  12      =2  #define USING_DPORDM_PIN 0
  13      =2  /*硬件是否启用充电使能引脚*/
  14      =2  #define USING_CHARGEING_PIN 0
  15      =2  
  16      =2  /*定义SC8913拓展IO*/
  17      =2  #if (USING_INT_PIN)
           =2 sbit INT_CHANNEL0 = P3^6;
           =2 sbit INT_CHANNEL1 = P3^2;
           =2 sbit INT_CHANNEL2 = P3^7;
           =2 #endif
  22      =2  
  23      =2  #if (USING_DPORDM_PIN)
           =2 sbit DP_CHANNEL0  = P2^1;
           =2 sbit DP_CHANNEL1  = P4^3;
           =2 sbit DP_CHANNEL2  = P0^4;
           =2 
           =2 sbit DM_CHANNEL0  = P2^2;
           =2 sbit DM_CHANNEL1  = P0^2;
           =2 sbit DM_CHANNEL2  = P0^3;
           =2 #endif
  32      =2  
  33      =2  sbit STOP_CHANNEL0  = P0^1;
  34      =2  sbit STOP_CHANNEL1  = P1^3;
  35      =2  sbit STOP_CHANNEL2  = P1^5;
  36      =2  
  37      =2  #if (USING_CHARGEING_PIN)
           =2 sbit CHARGER_CHANNEL0  = P2^4;
           =2 sbit CHARGER_CHANNEL1  = P2^5;
           =2 sbit CHARGER_CHANNEL2  = P2^6;
           =2 #endif
  42      =2  
  43      =2  /*通道数*/
  44      =2  #define CHANNEL_MAX         0x03
  45      =2  /*SC8913寄存器个数*/
  46      =2  #define REGISTER_MAX        0x1C
  47      =2  /*定时读取只读寄存器个数*/
  48      =2  #define READONLY_REGS       0x0B
  49      =2  /*定义支持写寄存器个数*/
  50      =2  #define WRITE_OPTION_REGS   0x0D
  51      =2  
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 20  

  52      =2  /*从机地址*/
  53      =2  #define SAVLE_ADDRESS       0x74
  54      =2  /*从机命令写地址*/
  55      =2  #define SAVLE_WRITE_ADDRESS 0xE8
  56      =2  /*从机命令读地址*/
  57      =2  #define SAVLE_READ_ADDRESS      0xE9
  58      =2  
  59      =2  /*SC8913寄存器地址定义*/
  60      =2  #define VBAT_SET_ADDR               0x00    /**/
  61      =2  #define VBUSREF_I_SET_ADDR              0x01
  62      =2  #define VBUSREF_I_SET2_ADDR             0x02
  63      =2  #define VBUSREF_E_SET_ADDR              0x03
  64      =2  #define VBUSREF_E_SET2_ADDR             0x04
  65      =2  #define IBUS_LIM_SET_ADDR               0x05
  66      =2  #define IBAT_LIM_SET_ADDR               0x06
  67      =2  #define VINREG_SET_ADDR             0x07
  68      =2  #define RATIO_ADDR                      0x08
  69      =2  #define CTRL0_SET_ADDR              0x09
  70      =2  #define CTRL1_SET_ADDR              0x0A
  71      =2  #define CTRL2_SET_ADDR              0x0B
  72      =2  #define CTRL3_SET_ADDR              0x0C
  73      =2  #define VBUS_FB_VALUE_ADDR              0x0D
  74      =2  #define VBUS_FB_VALUE2_ADDR             0x0E
  75      =2  #define VBAT_FB_VALUE_ADDR              0x0F
  76      =2  #define VBAT_FB_VALUE2_ADDR             0x10
  77      =2  #define IBUS_VALUE_ADDR             0x11
  78      =2  #define IBUS_VALUE2_ADDR                0x12
  79      =2  #define IBAT_VALUE_ADDR         0x13
  80      =2  #define IBAT_VALUE2_ADDR            0x14
  81      =2  #define ADIN_VALUE_ADDR         0x15
  82      =2  #define ADIN_VALUE_2_ADDR           0x16
  83      =2  #define STATUS_ADDR                     0x17
  84      =2  #define RESERVED_ADDR           0x18
  85      =2  #define MASK_ADDR                   0x19
  86      =2  #define DP_DM_CTRL_ADDR         0x1A
  87      =2  #define DP_DM_READ_ADDR         0x1B
  88      =2  
  89      =2  #define REG_OK      2U
  90      =2  #define REG_FAILE   3U
  91      =2  
  92      =2  
  93      =2  #define NAME(scr)       #scr
  94      =2  #define REG_R(r)        r##_Reg /*直接拼接字符串，不需要替换*/
  95      =2  #define REG_TYPE(t)     t##_Type
  96      =2  #define REG_Addr(a)     a##_Addr
  97      =2  #define REG_VALUE(v)    v##_U8
  98      =2  #define REG_BIT(b)      b##_Bit
  99      =2  #define BIT_HIGH(h)     b##h##_HIGHT8
 100      =2  #define BIT_LOW(l)      b##l##_LOW2
 101      =2  
 102      =2  /*IBUS端输入阈值电压：低于此值后，芯片将对BAT端限流*/
 103      =2  #define IBUS_THRESHOLD_VOLTAGE 20.0F
 104      =2  /*充电器输入端最大电流*/
 105      =2  #define IBUS_MAX_CURRENT    0.8333F
 106      =2  /*充电器充电通道最大输出电流*/
 107      =2  #define IBAT_MAX_CURRENT    2.00F
 108      =2  /*电路中电流、电压检测电阻：单位mΩ*/
 109      =2  #define CHECK_RESISTANCE     10.0F
 110      =2  /*BUS端输入电压倍率*/
 111      =2  #define VBUS_RAITO           12.5F
 112      =2  /*BAT端输入电压倍率:<9v时，采用5x,否则12.5x*/
 113      =2  #define VBAT_RATIO           5.0F
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 21  

 114      =2  /*BUS端输入电流倍率*/
 115      =2  #define IBUS_RAITO           3.0F
 116      =2  /*BAT端输入电流倍率*/
 117      =2  #define IBAT_RATIO           12.0F
 118      =2  /*电源输入电压比率*/
 119      =2  #define VINREG_RATIO         100.0F
 120      =2  /*设置BUS端电流上限*/
 121      =2  #define SET_IBUS_LIMT(x)     ((256U * (x * CHECK_RESISTANCE) - IBUS_RAITO * 10.0F) / (IBUS_RAITO * 10.0F))
 122      =2  /*设置BAT端电流上限*/
 123      =2  #define SET_IBAT_LIMT(x)     ((256U * (x * CHECK_RESISTANCE) - IBAT_RATIO * 10.0F) / (IBAT_RATIO * 10.0F))
 124      =2  /*设置电源输入电源电压*/
 125      =2  #define SET_VINREG_SET(x)    ((x * 1000.0F - VINREG_RATIO) / VINREG_RATIO)
 126      =2  /*设置VBUS内部参考编程电压*/
 127      =2  #define SET_VBUSREF_I_SET(x) (((x * 1000.0F)/ (2.0F * VBUS_RAITO) - 4.0F) / 4.0F)
 128      =2  /*1S-2S电池设置VBAT_MON_RATIO位为1;3S-4S电池设置VBAT_MON_RATIO位为0*/
 129      =2  #define SET_RATIO(x)         (x ? (0x02 | 0x38) : (0xFD & 0x38))
 130      =2  /*当AC_ok为0时，设置AC_DEF=0;当AC_ok为1时，设置AC_DEF=1*/
 131      =2  #define SET_CTRL0_SET(x)     (x ? (0x20 | 0x04) : (0xDF & 0x04)) 
 132      =2  /*x=1时，选择BAT端电流作为IBAT上限;x=0时，选择BUS端电流作为IBAT上限*/
 133      =2  #define SET_CTRL1_SET(x)     (x ? (0x80 | 0x01) : (0x7F & 0x01))
 134      =2  /*x=1时，退出工厂模式;x=0时，进入工厂模式*/
 135      =2  #define SET_CTRL2_SET(x)     (x ? (0x08 | 0x01) : (0xF7 & 0x01))
 136      =2  /*x=1时，打开ADC;x=0时，关闭ADC*/
 137      =2  #define SET_CTRL3_SET(x)     (x ? (0x20 | 0x02) : (0xDF & 0x02))
 138      =2  /*得到只读寄存器在g_Sc8913_Registers数组中下标*/
 139      =2  #define GET_SITE(x)           (x - VBUS_FB_VALUE_ADDR)
 140      =2  
 141      =2  #define READ_VBUS_VALUE(ch, addr)    ((4U * g_Sc8913_Registers[ch][addr] \
 142      =2                                    +  (((g_Sc8913_Registers[ch][addr + 1]) & 0xc0) >> 6U) + 1.0F) * 2.0F * 
             -VBUS_RAITO / 1000.0F)
 143      =2  #define READ_VBAT_VALUE(ch, addr)    ((4U * g_Sc8913_Registers[ch][addr] \
 144      =2                                    +  (((g_Sc8913_Registers[ch][addr + 1]) & 0xc0) >> 6U) + 1.0F) * 2.0F * 
             -VBAT_RATIO / 1000.0F)
 145      =2  #define READ_IBUS_VALUE(ch, addr)    ((4U * g_Sc8913_Registers[ch][addr] \
 146      =2                                    +  (((g_Sc8913_Registers[ch][addr + 1]) & 0xc0) >> 6U) + 1.0F) / 600.0F 
             -* IBUS_RAITO)
 147      =2  #define READ_IBAT_VALUE(ch, addr)    ((4U * g_Sc8913_Registers[ch][addr] \
 148      =2                                    +  (((g_Sc8913_Registers[ch][addr + 1]) & 0xc0) >> 6U) + 1.0F) / 600.0F 
             -* IBAT_RATIO)
 149      =2  
 150      =2  /*SC8913寄存器定义*/
 151      =2  typedef enum
 152      =2  {
 153      =2      Write = 0x00,
 154      =2      Read,
 155      =2      Both
 156      =2  }Reg_Type;
 157      =2  
 158      =2  /****************************************寄存器VBAT_SET************************************/
 159      =2  typedef enum
 160      =2  {
 161      =2      R_0m = 0x00, /*0mΩ*/
 162      =2      R_20m,
 163      =2      R_40m,
 164      =2      R_80m
 165      =2  }Vbat_IRCompensation;
 166      =2  
 167      =2  typedef enum
 168      =2  {
 169      =2      Inside_Mode = 0x00, /*内部模式*/
 170      =2      External_Mode
 171      =2  }Vbat_Mode;
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 22  

 172      =2  
 173      =2  typedef enum
 174      =2  {
 175      =2      One_Cell = 0x00, /*单节*/
 176      =2      Two_Cell,
 177      =2      Three_Cell,
 178      =2      Four_Cell
 179      =2  }Vbat_Units;
 180      =2  
 181      =2  typedef enum
 182      =2  {
 183      =2      V4_10 = 0x00, /*4.1V*/
 184      =2      V4_20,
 185      =2      V4_25,
 186      =2      V4_30,
 187      =2      V4_35,
 188      =2      V4_40,
 189      =2      V4_45,
 190      =2      V4_50
 191      =2  }Vbat_Units_Voltage;
 192      =2  
 193      =2  /*充电设置寄存器*/
 194      =2  typedef struct 
 195      =2  {
 196      =2          Reg_Type VBAT_SET_Type;
 197      =2      uint8_t  VBAT_SET_Addr;
 198      =2      union 
 199      =2          {
 200      =2                  struct 
 201      =2                  {
 202      =2                          uint8_t bIRCOMP  : 2; /*电池充电内部电阻补偿*/
 203      =2                          uint8_t bVBAT_SEL : 1; /*充电电压选择设置*/
 204      =2                          uint8_t bCSEL    : 2; /*内部电压设置模式下，充电电池节数选择*/
 205      =2                          uint8_t bVCELL_SET : 3; /*内部电压设置模式下，每节电池充电截止电压设置*/
 206      =2                  }VBAT_SET_Bit;
 207      =2                  uint8_t VBAT_SET_U8;    
 208      =2          }VBAT_SET;      
 209      =2  }VBAT_SET_Register;/*default value: 0x01*/ 
 210      =2  /****************************************寄存器VBAT_SET************************************/
 211      =2  
 212      =2  /****************************************寄存器VBUSREF_I_SET************************************/
 213      =2  /*电源总线内部模式参考电压设置寄存器*/
 214      =2  typedef struct 
 215      =2  {
 216      =2          Reg_Type VBUSREF_I_SET_Type;
 217      =2      uint8_t  VBUSREF_I_SET_Addr;
 218      =2      union 
 219      =2          {
 220      =2                  uint8_t VBUSREF_I_SET_U8; /*为内部VBUS编程设置的参考电压*/  
 221      =2          }VBUSREF_I_SET; 
 222      =2  }VBUSREF_I_SET_Register;/*default value: 0x31*/ 
 223      =2  
 224      =2  /*电源总线内部模式参考电压设置寄存器*/
 225      =2  typedef struct 
 226      =2  {
 227      =2          Reg_Type VBUSREF_I_SET2_Type;
 228      =2      uint8_t  VBUSREF_I_SET2_Addr;
 229      =2      union 
 230      =2          {
 231      =2                  struct 
 232      =2                  {
 233      =2                          uint8_t bVBUSREF_I_SET_2  : 2; /*为内部VBUS编程设置的参考电压*/
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 23  

 234      =2                          uint8_t bRESERVED : 6; 
 235      =2                  }VBUSREF_I_SET2_Bit;
 236      =2                  uint8_t VBUSREF_I_SET2_U8;      
 237      =2          }VBUSREF_I_SET2;        
 238      =2  }VBUSREF_I_SET2_Register;/*default value: 0x11xx xxxx*/ 
 239      =2  
 240      =2  /****************************************寄存器VBUSREF_I_SET************************************/
 241      =2  
 242      =2  /****************************************寄存器IBUS_LIM_SET************************************/
 243      =2  /*输入源电流上限设置寄存器*/
 244      =2  typedef struct 
 245      =2  {
 246      =2          Reg_Type IBUS_LIM_SET_Type;
 247      =2      uint8_t  IBUS_LIM_SET_Addr;
 248      =2      union 
 249      =2          {
 250      =2                  uint8_t IBUS_LIM_SET_U8; /*为内部VBUS编程设置的参考电压*/   
 251      =2          }IBUS_LIM_SET;  
 252      =2  }IBUS_LIM_SET_Register;/*default value: 0xFF*/ 
 253      =2  
 254      =2  /*输入源电压上限设置寄存器*/
 255      =2  typedef struct 
 256      =2  {
 257      =2          Reg_Type IBAT_LIM_SET_Type;
 258      =2      uint8_t  IBAT_LIM_SET_Addr;
 259      =2      union 
 260      =2          {
 261      =2                  uint8_t IBAT_LIM_SET_U8; /*为内部VBUS编程设置的参考电压*/   
 262      =2          }IBAT_LIM_SET;  
 263      =2  }IBAT_LIM_SET_Register;/*default value: 0xFF*/ 
 264      =2  
 265      =2  /*充电模式下，输入源电压范围设置寄存器*/
 266      =2  typedef struct 
 267      =2  {
 268      =2          Reg_Type VINRANG_SET_Type;
 269      =2      uint8_t  VINRANG_SET_Addr;
 270      =2      union 
 271      =2          {
 272      =2          uint8_t VINRANG_SET_U8; /*设置输入源电压的范围*/      
 273      =2          }VINRANG_SET;   
 274      =2  }VINRANG_SET_Register;/*default value: 0x2C*/ 
 275      =2  /****************************************寄存器寄存器IBUS_LIM_SET***********************************
             -*/
 276      =2  
 277      =2  /*BUS、BAT总线上电压、电流倍率设置寄存器*/
 278      =2  typedef struct 
 279      =2  {
 280      =2          Reg_Type RATIO_Type;
 281      =2      uint8_t  RATIO_Addr;
 282      =2      union 
 283      =2          {
 284      =2          struct 
 285      =2          {
 286      =2              uint8_t bNULL : 3;
 287      =2              uint8_t bIBAT_RATIO :1; /*设置BAT总线电流倍率*/
 288      =2              uint8_t bIBUS_RATIO : 2; /*设置BUS总线电流倍率*/
 289      =2              uint8_t bVBAT_MON_RATIO : 1;  /*设置BAT总线电压倍率*/
 290      =2              uint8_t bVBUS_RATIO : 1;  /*设置BAT总线电压倍率*/
 291      =2          }RATIO_Bit;
 292      =2          uint8_t RATIO_U8; /*设置BUS、BAT总线的电压、电流倍率*/     
 293      =2          }RATIO;
 294      =2  }RATIO_Register;/*default value: 0x38*/ 
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 24  

 295      =2  
 296      =2  /*CTRLX_SET设置寄存器*/
 297      =2  typedef struct 
 298      =2  {
 299      =2          Reg_Type CTRL0_SET_Type;
 300      =2      uint8_t  CTRL0_SET_Addr;
 301      =2      union 
 302      =2          {
 303      =2          struct 
 304      =2          {
 305      =2              uint8_t bEN_OTG : 1; /*充放电模式选择*/
 306      =2              uint8_t bNULL : 1; 
 307      =2              uint8_t bAC_DET : 1; /*交流插拔检测控制位*/
 308      =2              uint8_t bVINREG_RATIO : 1;  /*设置输入电源电压倍率*/
 309      =2              uint8_t bFREQ_SET : 1;  /*设置开关频率*/
 310      =2              uint8_t bDT_SET : 2; /*设置开关死区时间*/
 311      =2          }CTRL0_SET_Bit;
 312      =2          uint8_t CTRL0_SET_U8;   
 313      =2          }CTRL0_SET;     
 314      =2  }CTRL0_SET_Register;/*default value: 0x04*/ 
 315      =2  
 316      =2  typedef struct 
 317      =2  {
 318      =2          Reg_Type CTRL1_SET_Type;
 319      =2      uint8_t  CTRL1_SET_Addr;
 320      =2      union 
 321      =2          {
 322      =2          struct 
 323      =2          {
 324      =2              uint8_t bICHAE_SEL : 1; /*充电模式下，最终能够输出的电流极限参考选择（IB
             -US/IBAT）*/
 325      =2              uint8_t bDIS_TRICKLE : 1; /*是否启用涓流模式*/
 326      =2              uint8_t bDIS_TERM : 1; /*充电终止控制*/
 327      =2              uint8_t bFB_SEL : 1;  /*VBUS控制电压设置，仅适用于放电模式*/
 328      =2              uint8_t bTRICKLE_SET : 1;  /*涓流模式的开启设置为VBAT的%x，默认为VBAT*%60*/
 329      =2              uint8_t bDIS_OVP : 1; /*放电模式的OVP保护设置*/
 330      =2              uint8_t bNULL : 2;
 331      =2          }CTRL1_SET_Bit;
 332      =2          uint8_t CTRL1_SET_U8;   
 333      =2          }CTRL1_SET;     
 334      =2  }CTRL1_SET_Register;/*default value: 0x01*/
 335      =2  
 336      =2  typedef struct 
 337      =2  {
 338      =2          Reg_Type CTRL2_SET_Type;
 339      =2      uint8_t  CTRL2_SET_Addr;
 340      =2      union 
 341      =2          {
 342      =2          struct 
 343      =2          {
 344      =2              uint8_t bNULL : 4; 
 345      =2              uint8_t bFACTORY : 1; /*工厂设置位。通电后，MCU应将这一位写成1*/
 346      =2              uint8_t bEN_DITHEM : 1; /*是否启用开关频率抖动功能*/
 347      =2              uint8_t bSLEW_SET  : 2;  /*放电模式下的参考电压旋转率/变化速率设置*/
 348      =2          }CTRL2_SET_Bit;
 349      =2          uint8_t CTRL2_SET_U8;   
 350      =2          }CTRL2_SET;     
 351      =2  }CTRL2_SET_Register;/*default value: 0x01*/
 352      =2  
 353      =2  typedef struct 
 354      =2  {
 355      =2          Reg_Type CTRL3_SET_Type;
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 25  

 356      =2      uint8_t  CTRL3_SET_Addr;
 357      =2      union 
 358      =2          {
 359      =2          struct 
 360      =2          {
 361      =2              uint8_t bEN_PGATE : 1; /*PMOS控制*/ 
 362      =2              uint8_t bGPO_CTRL : 1; /*GPO输出控制*/
 363      =2              uint8_t bAD_START : 1; /*是否启用ADC*/
 364      =2              uint8_t bILIM_BW_SEL  : 1;  /*ILIM循环带宽设置*/
 365      =2              uint8_t bLOOP_SET : 1; /*循环响应控制*/
 366      =2              uint8_t bDIS_SHORTFOLDBACK : 1; /*IBUS电流折叠控制为VBUS短路情况，仅在放电模
             -下有效*/
 367      =2              uint8_t bEOC_SET : 1; /*充电结束阶段目标电流与充电电流倍率*/
 368      =2              uint8_t bEN_PFM  : 1; /*光照条件下的PFM控制，仅针对放电模式*/
 369      =2          }CTRL3_SET_Bit;
 370      =2          uint8_t CTRL3_SET_U8;   
 371      =2          }CTRL3_SET;     
 372      =2  }CTRL3_SET_Register;/*default value: 0x02*/
 373      =2  
 374      =2  /****************************************只读寄存器************************************/
 375      =2  typedef struct 
 376      =2  {
 377      =2          Reg_Type VBUS_FB_VALUE_Type;
 378      =2      uint8_t  VBUS_FB_VALUE_Addr;
 379      =2      union 
 380      =2          {
 381      =2          struct 
 382      =2          {
 383      =2              
 384      =2              uint8_t bVBUS_FB_VALUE_HULL : 6;
 385      =2              uint8_t bVBUS_FB_VALUE_HIGHT8 : 8;  
 386      =2              uint8_t bVBUS_FB_VALUE_LOW2   : 2;
 387      =2          }VBUS_FB_VALUE_Bit;
 388      =2          uint16_t VBUS_FB_VALUE_U8;      
 389      =2          }VBUS_FB_VALUE; 
 390      =2  }VBUS_FB_VALUE_Register;
 391      =2  
 392      =2  typedef struct 
 393      =2  {
 394      =2          Reg_Type VBAT_FB_VALUE_Type;
 395      =2      uint8_t  VBAT_FB_VALUE_Addr;
 396      =2      union 
 397      =2          {
 398      =2          struct 
 399      =2          {
 400      =2              
 401      =2              uint8_t bVBAT_FB_VALUE_HULL : 6;
 402      =2              uint8_t bVBAT_FB_VALUE_HIGHT8 : 8;  
 403      =2              uint8_t bVBAT_FB_VALUE_LOW2   : 2;
 404      =2          }VBAT_FB_VALUE_Bit;
 405      =2          uint16_t VBAT_FB_VALUE_U8;      
 406      =2          }VBAT_FB_VALUE; 
 407      =2  }VBAT_FB_VALUE_Register;
 408      =2  
 409      =2  typedef struct 
 410      =2  {
 411      =2          Reg_Type IBUS_FB_VALUE_Type;
 412      =2      uint8_t  IBUS_FB_VALUE_Addr;
 413      =2      union 
 414      =2          {
 415      =2          struct 
 416      =2          {
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 26  

 417      =2              
 418      =2              uint8_t bIBUS_FB_VALUE_HULL : 6;
 419      =2              uint8_t bIBUS_FB_VALUE_HIGHT8 : 8;  
 420      =2              uint8_t bIBUS_FB_VALUE_LOW2   : 2;
 421      =2          }IBUS_FB_VALUE_Bit;
 422      =2          uint16_t IBUS_FB_VALUE_U8;      
 423      =2          }IBUS_FB_VALUE; 
 424      =2  }IBUS_FB_VALUE_Register;
 425      =2  
 426      =2  typedef struct 
 427      =2  {
 428      =2          Reg_Type IBAT_FB_VALUE_Type;
 429      =2      uint8_t  IBAT_FB_VALUE_Addr;
 430      =2      union 
 431      =2          {
 432      =2          struct 
 433      =2          {
 434      =2              
 435      =2              uint8_t bIBAT_FB_VALUE_HULL : 6;
 436      =2              uint8_t bIBAT_FB_VALUE_HIGHT8 : 8;  
 437      =2              uint8_t bIBAT_FB_VALUE_LOW2   : 2;
 438      =2          }IBAT_FB_VALUE_Bit;
 439      =2          uint16_t IBAT_FB_VALUE_U8;      
 440      =2          }IBAT_FB_VALUE; 
 441      =2  }IBAT_FB_VALUE_Register;
 442      =2  
 443      =2  
 444      =2  typedef struct 
 445      =2  {
 446      =2          Reg_Type MASK_Type;
 447      =2      uint8_t  MASK_Addr;
 448      =2      union 
 449      =2          {
 450      =2          struct 
 451      =2          {
 452      =2              
 453      =2              uint8_t bDM_L_MASK : 1; /*检测到DM中断设置位*/
 454      =2              uint8_t bAC_OK_MASK : 1; /*插入交流适配器中断设置位*/  
 455      =2              uint8_t bINDET2_MASK : 1; /*USB-A在INDET2针脚处检测到一个负载插入中断设置位*
             -/
 456      =2              uint8_t bINDET1_MASK : 1; /*USB-A在INDET1针脚处检测到一个负载插入中断设置位*
             -/
 457      =2              uint8_t bVBUS_SHORT_MASK : 1; /*在放电模式下发生VBUS短路故障中断设置位*/
 458      =2              uint8_t bVBUS_OTP_MASK : 1; /*OTP故障发生中断设置位*/
 459      =2              uint8_t bVBUS_EOC_MASK : 1; /*满足EOC条件中断设置位*/
 460      =2              uint8_t bNULL : 1;
 461      =2          }MASK_Bit;
 462      =2          uint8_t MASK_U8;        
 463      =2          }MASK;  
 464      =2  }MASK_Register;
 465      =2  
 466      =2  /****************************************只读寄存器************************************/
 467      =2  
 468      =2  
 469      =2  typedef struct 
 470      =2  {
 471      =2          Reg_Type STATUS_Type;
 472      =2      uint8_t  STATUS_Addr;
 473      =2      union 
 474      =2          {
 475      =2          struct 
 476      =2          {
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 27  

 477      =2              
 478      =2              uint8_t bDM_L : 1; /*检测到DM电压低于0.325V*/
 479      =2              uint8_t bAC_OK : 1; /*插入交流适配器*/  
 480      =2              uint8_t bINDET2 : 1; /*USB-A在INDET2针脚处检测到一个负载插入*/
 481      =2              uint8_t bINDET1 : 1; /*USB-A在INDET1针脚处检测到一个负载插入*/
 482      =2              uint8_t bVBUS_SHORT : 1; /*在放电模式下发生VBUS短路故障*/
 483      =2              uint8_t bVBUS_OTP : 1; /*OTP故障发生*/
 484      =2              uint8_t bVBUS_EOC : 1; /*满足EOC条件*/
 485      =2              uint8_t bNULL : 1;
 486      =2          }STATUS_Bit;
 487      =2          uint8_t STATUS_U8;      
 488      =2          }STATUS;        
 489      =2  }STATUS_Register;
 490      =2  
 491      =2  extern data uint8_t g_Sc8913_Registers[CHANNEL_MAX][REGISTER_MAX]; 
 492      =2  extern uint8_t Sc8913_Init(void);
 493      =2  extern void Set_Sc8913_Stop(IIC_Channel channel, IIC_Pin_State state);
 494      =2  extern void Set_Sc8913_charger(IIC_Channel channel, IIC_Pin_State state);
 495      =2  extern uint8_t Sc8913_Write_Register(IIC_Channel channel, uint8_t start_addr, uint8_t *dat, uint8_t length
             -);
 496      =2  extern uint8_t Sc8913_Read_Register(IIC_Channel channel, uint8_t start_addr, uint8_t *dat, uint8_t length)
             -;
 497      =2  extern uint8_t Read_Register_Value(IIC_Channel channel);
 498      =2  #ifdef __cplusplus
           =2 }
           =2 #endif
 501      =2  
 502      =2  #endif /* __SC8913_H */
   8      =1  
   9      =1  /*SC9813最低检测电流>0.3A*/
  10      =1  #define CHECK_CURRENT       0.3F
  11      =1  /*涓流阶段电流时IBAT的1/10*/
  12      =1  #define TRICKLE_CURRNET     (0.1F * IBAT_MAX_CURRENT)
  13      =1  /*通道电压下限2.0V*/
  14      =1  #define LOWEST_VOLTAGE          2.0F      
  15      =1  /*锂电池单节允许最高电压*/
  16      =1  #define ONCE_MAXVOLTAGE     4.20F
  17      =1  /*锂电池单节允许最低电压为SC8913BAT电压的70%*/
  18      =1  #define ONCE_MINVOLTAGE     (ONCE_MAXVOLTAGE * 0.7F)
  19      =1  /*SC8913认为充满时电压*/
  20      =1  #define ONCE_FULLVOLTAGE    (ONCE_MAXVOLTAGE * 0.98F)
  21      =1  /*断路次数*/
  22      =1  #define OPENTIME            50U
  23      =1  
  24      =1  /*定义STATUS寄存器位*/
  25      =1  #define EOC_BIT 0x01
  26      =1  #define OTP_BIT 0x02
  27      =1  #define VBUS_SHORT_BIT 0x03
  28      =1  #define INDET1_BIT 0x04
  29      =1  #define INDET2_BIT 0x05
  30      =1  #define AC_OK_BIT 0x06
  31      =1  #define DM_L_BIT 0x07
  32      =1  
  33      =1  #define REVISE_REGISTER(ch, value, ratio, result) \
  34      =1  do \
  35      =1  { \
  36      =1      if(Sc8913_Write_Register(ch->Channel_Id, VBAT_SET_ADDR, &value ,1U)) \
  37      =1      { \
  38      =1          result = true; \
  39      =1      } \
  40      =1      if(ratio == true) \
  41      =1      { \
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 28  

  42      =1          p_ch->Vbat_Ratio = VBAT_RATIO; \
  43      =1      }\
  44      =1      else \
  45      =1      { \
  46      =1          p_ch->Vbat_Ratio = VBAT_RATIO * 2.5F; \
  47      =1      } \
  48      =1          value = SET_RATIO(ratio); \
  49      =1          if(Sc8913_Write_Register(ch->Channel_Id, RATIO_ADDR, &value ,1U)) \
  50      =1      { \
  51      =1          result = true; \
  52      =1      } \
  53      =1  }while(0);
  54      =1  
  55      =1  
  56      =1  /*设备类型*/
  57      =1  typedef enum
  58      =1  {
  59      =1          Cell = 0x00,
  60      =1          Dcdc,
  61      =1          No_Device,
  62      =1  }Device_Type;
  63      =1  
  64      =1  /*充电状态*/
  65      =1  typedef enum
  66      =1  {   
  67      =1      /*涓流充电*/
  68      =1          Trickle_Mode = 0x00,
  69      =1      /*恒流充电*/    
  70      =1          Constant_Current_Mode,
  71      =1      /*恒压充电*/    
  72      =1          Constant_Voltage_Mode,
  73      =1      /*充电结束*/    
  74      =1          End_Charging,   
  75      =1      /*待机模式*/
  76      =1      stdantby_Mode       
  77      =1  }Charging_State;    
  78      =1  
  79      =1  /*前台实时上报数据*/
  80      =1  typedef struct
  81      =1  {   /*上报的电压*/
  82      =1          float Voltage;
  83      =1      /*上报的电流*/ 
  84      =1          float Current;
  85      =1      /*充电时长*/    
  86      =1          uint32_t Time;  
  87      =1      /*充电电量*/
  88      =1          float Electricity; 
  89      =1  }Foreground_Parameters;     
  90      =1  
  91      =1  /*后台上报数据*/
  92      =1  typedef struct
  93      =1  {
  94      =1          float Trickle_Target_Current;                   //涓流目标电流
  95      =1          float Trickle_Target_Voltage;                   //涓流目标电压
  96      =1  
  97      =1          float ConstantCurrent_Target_Current;   //恒流目标电流
  98      =1          float ConstantCurrent_Target_Voltage;   //恒流目标电压
  99      =1  
 100      =1          float ConstantVoltage_Target_Current;   //恒压目标电流
 101      =1          float ConstantVoltage_Target_Voltage;   //恒压目标电压
 102      =1  }Background_Parameters;
 103      =1  
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 29  

 104      =1  
 105      =1  typedef struct 
 106      =1  {
 107      =1      /*当前通道ID*/
 108      =1      IIC_Channel Channel_Id;
 109      =1      /*设备类型*/    
 110      =1      Device_Type    Dev_Type;
 111      =1      /*锂电池节数*/
 112      =1      uint8_t Batterry_Numbers;
 113      =1      /*充电状态*/
 114      =1          Charging_State  CState;
 115      =1      /*前台参数*/
 116      =1      Foreground_Parameters For_ChargingPara;
 117      =1      Background_Parameters Bac_ChargingPara;
 118      =1      struct 
 119      =1      {   /*充电器后台参数地址*/
 120      =1          uint32_t Back_Para_Addr;                                   
 121      =1          /*充电动画地址*/
 122      =1              uint32_t Animation_Addr;      
 123      =1          /*充电状态地址*/
 124      =1              uint32_t State_Addr;
 125      =1      }Charger_Show_Addr;    
 126      =1      struct 
 127      =1      {   /*正在充电标志*/
 128      =1          volatile uint8_t Is_ChargingFlag;
 129      =1          /*充电动画状态 */                    
 130      =1              volatile uint8_t Cartoon_Flag;
 131      =1          /*过流标志*/        
 132      =1              volatile uint8_t OverCurrent_Flag;   
 133      =1      }Charger_Flag; 
 134      =1      /*不同电池节数下的VBA倍率*/
 135      =1      float Vbat_Ratio;          
 136      =1  }Charging_Typedef;
 137      =1  
 138      =1  extern const Charging_Typedef g_Charger[CHANNEL_MAX];
 139      =1  extern void Charging_Poll(Charging_Typedef *const p_ch);
 140      =1  extern void Report_ChargerInfo(Charging_Typedef *const p_ch);
 141      =1  #ifdef __cplusplus
           =1 }
           =1 #endif
 144      =1  
 145      =1  #endif /* __SC8913_H */
   2          #include "Dwin.h"
   1      =1  /*
   2      =1   * Dwin.h
   3      =1   *
   4      =1   *  Created on: Nov 19, 2020
   5      =1   *      Author: play
   6      =1   */
   7      =1  
   8      =1  #ifndef INC_DWIN_H_
   9      =1  #define INC_DWIN_H_
  10      =1  
  11      =1  #include "config.h"
   1      =2  #ifndef __CONFIG_H_
           =2 #define __CONFIG_H_
           =2 
           =2 #include <STC8.H>
           =2 #include <stdio.h>
           =2 #include <intrins.h>
           =2 #include <string.h>
           =2 #include <stdlib.h>
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 30  

           =2 #include <string.h>
           =2 #include <absacc.h> //可直接操作内存地址
           =2 #include <stdarg.h>
           =2 
           =2 
           =2 /**********************布尔变量定义**********************/
           =2 #define true  1
           =2 #define false 0
           =2 /**********************布尔变量定义**********************/
           =2 
           =2 /***********************************API配置接口***********************************/
           =2 /*使用外部晶振*/
           =2 #define EXTERNAL_CRYSTAL 0 
           =2 /*调试是否启用串口*/
           =2 #define USE_PRINTF_DEBUG 0 
           =2 /*调试选项*/
           =2 #define DEBUGGING    0
           =2 /*迪文屏幕使用CRC校验*/
           =2 #define USING_CRC 1
           =2 /*定义WIFI模块相关引脚*/
           =2 #define WIFI_RESET              P23
           =2 #define WIFI_RELOAD             P20
           =2 
           =2 #define COUNTMAX     65536U
           =2 
           =2 /*消除编译器未使用变量警告*/
           =2 #define UNUSED_VARIABLE(x)      ((void)(x))
           =2 #define UNUSED_PARAMETER(x) UNUSED_VARIABLE(x)
           =2 
           =2 //(1/FOSC)*count =times(us)->count = time*FOSC/1000(ms)
           =2 #define FOSC         27000000UL//11059200UL
           =2 /*1ms(时钟频率越高，所能产生的时间越小)*/  
           =2 #define TIMES        10U  
           =2 /*定时器模式选择*/
           =2 #define TIMER_MODE   12U
           =2 /*定时器分频系数，默认为一分频*/  
           =2 #define TIME_DIV     1U  
           =2 #define T12_MODE (TIMES * FOSC / 1000 / 12 / TIME_DIV) 
           =2 #define T1_MODE  (TIMES * FOSC/ 1000 / TIME_DIV)
           =2 #define TIMERS_OVERFLOW (COUNTMAX * 1000 * TIMER_MODE * TIME_DIV) / FOSC
           =2 
           =2 #define OPEN_GLOBAL_OUTAGE()  (EA = 1 << 0)
           =2 #define CLOSE_GLOBAL_OUTAGE() (EA = 0 << 0)
           =2 /*判断延时数是否超出硬件允许范围*/
           =2 #if(TIMES > TIMERS_OVERFLOW)
           =2 #error The timer cannot generate the current duration!
           =2 #endif
           =2 /***********************************API配置接口***********************************/
           =2 
           =2 /***********************************常用的数据类型***********************************/
           =2 typedef unsigned char  uint8_t;
           =2 typedef signed char    int8_t;
           =2 typedef unsigned short int  uint16_t;
           =2 typedef unsigned long  uint32_t;
           =2 typedef signed long    int32_t;
           =2 typedef volatile       __IO;   
           =2 
           =2 /***********************************常用的数据类型***********************************/
           =2 
           =2 /***********************************系统上电参数***********************************/
           =2 #define DEFAULT_SYSTEM_PARAMETER  "\xFF\xFF\xFF\xFF\x02\x01\x00\x84\x50"
           =2 
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 31  

           =2 /***********************************系统上电参数***********************************/
           =2 
           =2 /***********************************结构体的妙用 ***********************************/
           =2 /*获得结构体(TYPE)的变量成员(MEMBER)在此结构体中的偏移量*/ 
           =2 #define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
           =2 /*根据"结构体(type)变量"中的"域成员变量(member)的指针(ptr)"来获取指向整个结构体
             -变量的指针*/ 
           =2 #define container_of(ptr, type, member) ({ \
           =2         const typeof( ((type *)0)->member ) *__mptr = (ptr); \
           =2         (type *)( (char *)__mptr - offsetof(type,member) );}) 
           =2 /***********************************结构体的妙用 ***********************************/
           =2 
           =2 
           =2 extern const uint8_t g_TimerNumbers;
           =2 /***********************************函数声明***********************************/
           =2 void  Gpio_Init(void);
           =2 /***********************************函数声明***********************************/
           =2 #endif
  12      =1  
  13      =1  #define RX_BUF_SIZE      128
  14      =1  #define TX_BUF_SIZE  128
  15      =1  
  16      =1  #define WRITE_CMD        0x82           //写
  17      =1  #define READ_CMD         0x83           //读
  18      =1  
  19      =1  #define PAGE_CHANGE_CMD  0x84   //页面切换
  20      =1  #define TOUCH_CMD            0xD4   //触摸动作
  21      =1  
  22      =1  
  23      =1  #define SHOW_YEAR_ADDR                                                  0x1000     //年显示地址
  24      =1  #define SHOW_MONTH_ADDR                                                 0x1001     //月显示地址
  25      =1  #define SHOW_DATE_ADDR                                                  0x1002     //日显示地址
  26      =1  #define SHOW_WEEK_ADDR                                                  0x1003     //周显示地址
  27      =1  #define SHOW_HOUR_ADDR                                                  0x1004     //时显示地址
  28      =1  #define SHOW_MIN_ADDR                                                   0x1005     //分显示地址
  29      =1  
  30      =1  #define SETTING_YEAR_ADDR                                               0x1200     //年显示地址
  31      =1  #define SETTING_MONTH_ADDR                                              0x1210     //月显示地址
  32      =1  #define SETTING_DATE_ADDR                                               0x1220     //日显示地址
  33      =1  #define SETTING_HOUR_ADDR                                               0x1230     //时显示地址
  34      =1  #define SETTING_MIN_ADDR                                                0x1240     //分显示地址
  35      =1  
  36      =1  #define TRICKLE_CHARGE_CURRENT1_ADDR                    0x1010     //涓流充电充电电流
  37      =1  #define TRICKLE_CHARGE_TARGET_VOLTAGE1_ADDR             0x1012     //涓流充电目标电压
  38      =1  #define CONSTANT_CURRENT_CURRENT1_ADDR                  0x1014     //恒流充电充电电流
  39      =1  #define CONSTANT_CURRENT_TARGET_VOLTAGE1_ADDR   0x1016     //恒流充电目标电压
  40      =1  #define CONSTANT_VOLTAGE_VOLTAGE1_ADDR                  0x1018     //恒压充电充电电压
  41      =1  #define CONSTANT_VOLTAGE_TARGET_CURRENT1_ADDR   0x101A     //恒压充电阈值电流
  42      =1  
  43      =1  #define CHARGE_VOLTAGE_NOW1_ADDR                                0x1020     //当前充电电压
  44      =1  #define CHARGE_CURRENT_NOW1_ADDR                                0x1022     //当前充电电流
  45      =1  #define CHARGE_TIME_NOW1_ADDR                               0x1024     //当前充电时长
  46      =1  #define CHARGE_QUANTITY_NOW1_ADDR                               0x1026     //当前充电电量
  47      =1  
  48      =1  #define TRICKLE_CHARGE_CURRENT2_ADDR                    0x1030     //涓流充电充电电流
  49      =1  #define TRICKLE_CHARGE_TARGET_VOLTAGE2_ADDR             0x1032     //涓流充电目标电压
  50      =1  #define CONSTANT_CURRENT_CURRENT2_ADDR                  0x1034     //恒流充电充电电流
  51      =1  #define CONSTANT_CURRENT_TARGET_VOLTAGE2_ADDR   0x1036     //恒流充电目标电压
  52      =1  #define CONSTANT_VOLTAGE_VOLTAGE2_ADDR                  0x1038     //恒压充电充电电压
  53      =1  #define CONSTANT_VOLTAGE_TARGET_CURRENT2_ADDR   0x103A     //恒压充电阈值电流
  54      =1  
  55      =1  #define CHARGE_VOLTAGE_NOW2_ADDR                                0x1040     //当前充电电压
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 32  

  56      =1  #define CHARGE_CURRENT_NOW2_ADDR                                0x1042     //当前充电电流
  57      =1  #define CHARGE_TIME_NOW2_ADDR                               0x1044         //当前充电时长
  58      =1  #define CHARGE_QUANTITY_NOW2_ADDR                               0x1046     //当前充电电量
  59      =1  
  60      =1  #define TRICKLE_CHARGE_CURRENT3_ADDR                    0x1050     //涓流充电充电电流
  61      =1  #define TRICKLE_CHARGE_TARGET_VOLTAGE3_ADDR             0x1052     //涓流充电目标电压
  62      =1  #define CONSTANT_CURRENT_CURRENT3_ADDR                  0x1054     //恒流充电充电电流
  63      =1  #define CONSTANT_CURRENT_TARGET_VOLTAGE3_ADDR   0x1056     //恒流充电目标电压
  64      =1  #define CONSTANT_VOLTAGE_VOLTAGE3_ADDR                  0x1058     //恒压充电充电电压
  65      =1  #define CONSTANT_VOLTAGE_TARGET_CURRENT3_ADDR   0x105A     //恒压充电阈值电流
  66      =1  
  67      =1  #define CHARGE_VOLTAGE_NOW3_ADDR                                0x1060     //当前充电电压
  68      =1  #define CHARGE_CURRENT_NOW3_ADDR                                0x1062     //当前充电电流
  69      =1  #define CHARGE_TIME_NOW3_ADDR                               0x1064     //当前充电时长
  70      =1  #define CHARGE_QUANTITY_NOW3_ADDR                               0x1066     //当前充电电量
  71      =1  
  72      =1  #define SHOW_ANIMATION1_ADDR                                    0x2000     //电池充电动画1
  73      =1  #define SHOW_ANIMATION2_ADDR                                    0x2010     //电池充电动画2
  74      =1  #define SHOW_ANIMATION3_ADDR                                    0x2020     //电池充电动画3
  75      =1  
  76      =1  #define CHARGE_STATE1_ADDR                                              0x2030     //电池充电状态1
  77      =1  #define CHARGE_STATE2_ADDR                                              0x2040     //电池充电状态2
  78      =1  #define CHARGE_STATE3_ADDR                                              0x2050     //电池充电状态3
  79      =1  
  80      =1  #define CHARGE_STATE_NOW1_ADDR                                  0x1028     //当前充电状态
  81      =1  #define CHARGE_STATE_NOW2_ADDR                                  0x1048     //当前充电状态
  82      =1  #define CHARGE_STATE_NOW3_ADDR                                  0x1068     //当前充电状态
  83      =1  
  84      =1  #define PARAM_START_ADDR                        0x3000     //电源管理芯片内部参数显示地址
  85      =1  #define DWIN_ADDR_OFFSET                        0x0020     //迪文屏幕变量便宜地址
  86      =1  
  87      =1  typedef struct
  88      =1  {
  89      =1          uint8_t RxBuf[RX_BUF_SIZE];
  90      =1          uint16_t RxCount;
  91      =1  
  92      =1          uint8_t TxBuf[TX_BUF_SIZE];
  93      =1          uint16_t TxCount;
  94      =1  }Dwin_T;
  95      =1  
  96      =1  typedef void (*pfunc)(uint8_t*,uint8_t);
  97      =1  typedef struct
  98      =1  {
  99      =1          uint32_t addr;
 100      =1          pfunc event;
 101      =1  }DwinMap;
 102      =1  
 103      =1  
 104      =1  extern Dwin_T g_Dwin;
 105      =1  extern void Dwin_SendWithCRC(uint8_t *_pBuf, uint16_t _ucLen);
 106      =1  extern void Dwin_Send(uint8_t *_pBuf, uint16_t _ucLen);
 107      =1  extern void Dwin_Write(uint16_t start_addr, uint8_t *dat, uint16_t length);
 108      =1  extern void Dwin_Read(uint16_t start_addr, uint16_t words);
 109      =1  extern uint16_t Get_Crc16(uint8_t *ptr, uint16_t length, uint16_t init_dat);
 110      =1  
 111      =1  #endif /* INC_DWIN_H_ */
   3          #include "ModbusMaster.h"
   1      =1  /*
   2      =1   * ModbusMaster.h
   3      =1   *
   4      =1   *  Created on: 2021年1月29日
   5      =1   *      Author: play
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 33  

   6      =1   */
   7      =1  
   8      =1  #ifndef INC_MODBUSMASTER_H_
   9      =1  #define INC_MODBUSMASTER_H_
  10      =1  
  11      =1  #include "config.h"
   1      =2  #ifndef __CONFIG_H_
           =2 #define __CONFIG_H_
           =2 
           =2 #include <STC8.H>
           =2 #include <stdio.h>
           =2 #include <intrins.h>
           =2 #include <string.h>
           =2 #include <stdlib.h>
           =2 #include <string.h>
           =2 #include <absacc.h> //可直接操作内存地址
           =2 #include <stdarg.h>
           =2 
           =2 
           =2 /**********************布尔变量定义**********************/
           =2 #define true  1
           =2 #define false 0
           =2 /**********************布尔变量定义**********************/
           =2 
           =2 /***********************************API配置接口***********************************/
           =2 /*使用外部晶振*/
           =2 #define EXTERNAL_CRYSTAL 0 
           =2 /*调试是否启用串口*/
           =2 #define USE_PRINTF_DEBUG 0 
           =2 /*调试选项*/
           =2 #define DEBUGGING    0
           =2 /*迪文屏幕使用CRC校验*/
           =2 #define USING_CRC 1
           =2 /*定义WIFI模块相关引脚*/
           =2 #define WIFI_RESET              P23
           =2 #define WIFI_RELOAD             P20
           =2 
           =2 #define COUNTMAX     65536U
           =2 
           =2 /*消除编译器未使用变量警告*/
           =2 #define UNUSED_VARIABLE(x)      ((void)(x))
           =2 #define UNUSED_PARAMETER(x) UNUSED_VARIABLE(x)
           =2 
           =2 //(1/FOSC)*count =times(us)->count = time*FOSC/1000(ms)
           =2 #define FOSC         27000000UL//11059200UL
           =2 /*1ms(时钟频率越高，所能产生的时间越小)*/  
           =2 #define TIMES        10U  
           =2 /*定时器模式选择*/
           =2 #define TIMER_MODE   12U
           =2 /*定时器分频系数，默认为一分频*/  
           =2 #define TIME_DIV     1U  
           =2 #define T12_MODE (TIMES * FOSC / 1000 / 12 / TIME_DIV) 
           =2 #define T1_MODE  (TIMES * FOSC/ 1000 / TIME_DIV)
           =2 #define TIMERS_OVERFLOW (COUNTMAX * 1000 * TIMER_MODE * TIME_DIV) / FOSC
           =2 
           =2 #define OPEN_GLOBAL_OUTAGE()  (EA = 1 << 0)
           =2 #define CLOSE_GLOBAL_OUTAGE() (EA = 0 << 0)
           =2 /*判断延时数是否超出硬件允许范围*/
           =2 #if(TIMES > TIMERS_OVERFLOW)
           =2 #error The timer cannot generate the current duration!
           =2 #endif
           =2 /***********************************API配置接口***********************************/
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 34  

           =2 
           =2 /***********************************常用的数据类型***********************************/
           =2 typedef unsigned char  uint8_t;
           =2 typedef signed char    int8_t;
           =2 typedef unsigned short int  uint16_t;
           =2 typedef unsigned long  uint32_t;
           =2 typedef signed long    int32_t;
           =2 typedef volatile       __IO;   
           =2 
           =2 /***********************************常用的数据类型***********************************/
           =2 
           =2 /***********************************系统上电参数***********************************/
           =2 #define DEFAULT_SYSTEM_PARAMETER  "\xFF\xFF\xFF\xFF\x02\x01\x00\x84\x50"
           =2 
           =2 /***********************************系统上电参数***********************************/
           =2 
           =2 /***********************************结构体的妙用 ***********************************/
           =2 /*获得结构体(TYPE)的变量成员(MEMBER)在此结构体中的偏移量*/ 
           =2 #define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
           =2 /*根据"结构体(type)变量"中的"域成员变量(member)的指针(ptr)"来获取指向整个结构体
             -变量的指针*/ 
           =2 #define container_of(ptr, type, member) ({ \
           =2         const typeof( ((type *)0)->member ) *__mptr = (ptr); \
           =2         (type *)( (char *)__mptr - offsetof(type,member) );}) 
           =2 /***********************************结构体的妙用 ***********************************/
           =2 
           =2 
           =2 extern const uint8_t g_TimerNumbers;
           =2 /***********************************函数声明***********************************/
           =2 void  Gpio_Init(void);
           =2 /***********************************函数声明***********************************/
           =2 #endif
  12      =1  
  13      =1  #define  SLAVEADDRESS         0x02
  14      =1  #define  MOD_RX_BUF_SIZE      128U
  15      =1  #define  MOD_TX_BUF_SIZE      128U
  16      =1  
  17      =1  typedef struct
  18      =1  {
  19      =1          uint8_t RxBuf[MOD_RX_BUF_SIZE];
  20      =1          uint16_t RxCount;
  21      =1          uint8_t RxStatus;
  22      =1          uint8_t RxNewFlag;
  23      =1  
  24      =1          uint8_t TxBuf[MOD_TX_BUF_SIZE];
  25      =1          uint16_t TxCount;
  26      =1  }MODS_T;
  27      =1  
  28      =1  extern MODS_T g_tModS;
  29      =1  
  30      =1  
  31      =1  void MOD_46H(uint8_t slaveaddr,uint16_t regaddr,uint16_t reglength,uint8_t datalength,uint8_t* dat);
  32      =1  
  33      =1  #endif /* INC_MODBUSMASTER_H_ */
   4          
   5          uint8_t g_Cloud_Buffer[CHANNEL_MAX * sizeof(float) * 4U] = {0};
   6          
   7          /*初始化各充电通道*/
   8          const Charging_Typedef g_Charger[CHANNEL_MAX] =
   9          {        /*通道1*/
  10                   {Channel0, No_Device, 0U, stdantby_Mode, {0.0F, 0.0F, 0U, 0.0F}, {0.0F, 0.0F, 0.0F, 0.0F}, {TRICKLE_CHAR
             -GE_CURRENT1_ADDR, SHOW_ANIMATION1_ADDR, CHARGE_STATE_NOW1_ADDR}, {false, false, false}, VBAT_RATIO}, /*参数默认VBAT
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 35  

             -率为5x，可以充1s-2s*/
  11                   /*通道2*/
  12                   {Channel1, No_Device, 0U, stdantby_Mode, {0.0F, 0.0F, 0U, 0.0F}, {0.0F, 0.0F, 0.0F, 0.0F}, {TRICKLE_CHAR
             -GE_CURRENT2_ADDR, SHOW_ANIMATION2_ADDR, CHARGE_STATE_NOW2_ADDR}, {false, false, false}, VBAT_RATIO},
  13                   /*通道3*/
  14                   {Channel2, No_Device, 0U, stdantby_Mode, {0.0F, 0.0F, 0U, 0.0F}, {0.0F, 0.0F, 0.0F, 0.0F}, {TRICKLE_CHAR
             -GE_CURRENT3_ADDR, SHOW_ANIMATION3_ADDR, CHARGE_STATE_NOW3_ADDR}, {false, false, false}, VBAT_RATIO}
  15          };
  16          
  17          /*按单个锂电池计算*/
  18          static const float Battery_Interval[][2] =
  19          {
  20                          {1U * ONCE_MINVOLTAGE, 1U * ONCE_MAXVOLTAGE},
  21                          {2U * ONCE_MINVOLTAGE, 2U * ONCE_MAXVOLTAGE},
  22                          {3U * ONCE_MINVOLTAGE, 3U * ONCE_MAXVOLTAGE},
  23                          {4U * ONCE_MINVOLTAGE, 4U * ONCE_MAXVOLTAGE}
  24          };
  25          
  26          /*检查电池接入*/
  27          static uint8_t Get_Battery_Range(float persent_voltage);
  28          static uint8_t Set_Charging_Mode(Charging_Typedef *const p_ch);
  29          static uint8_t Get_StatusBit(Charging_Typedef *const p_ch, uint8_t abit);
  30          static uint8_t Set_AcDef(Charging_Typedef *const p_ch);
  31          static uint8_t Check_Connect(Charging_Typedef *const p_ch);
  32          /*获取充电设备后台充电参数*/
  33          static void Get_BackCharging_Parameters(Charging_Typedef *const p_ch);
  34          static void Get_NowChargingMode(Charging_Typedef *const p_ch);
  35          /*检查设备是否断开连接*/
  36          static uint8_t Check_DisConnect(Charging_Typedef *const p_ch);
  37          static void ChargingStage_Monitor(Charging_Typedef *const p_ch);
  38          static void Set_Charging_Amimation(uint8_t state, uint32_t addr);
  39          static void Set_Charging_State(Charging_State state, uint32_t addr);
  40          
  41          /*不优化*/
  42          // #pragma OPTIMIZE(0)
  43          /**
  44           * @brief       充电器上报信息处理
  45           * @details     
  46           * @param       p_ch:当前通道
  47           * @retval      None
  48           */
  49          void Report_ChargerInfo(Charging_Typedef *const p_ch)
  50          {
  51   1              Foreground_Parameters Report = {0};
  52   1              uint16_t back_addr = CHARGE_VOLTAGE_NOW1_ADDR + DWIN_ADDR_OFFSET * p_ch->Channel_Id;
  53   1              uint16_t param_addr = PARAM_START_ADDR + DWIN_ADDR_OFFSET * p_ch->Channel_Id;
  54   1              uint8_t temp_buf[REGISTER_MAX * 2U] = {0};
  55   1              uint8_t i = 0;
  56   1              static uint8_t counter = 0;
  57   1      
  58   1              for(i = 0; i < (REGISTER_MAX * 2U); i += 2U)
  59   1              {
  60   2                      temp_buf[i] = 0x00;
  61   2                      temp_buf[i + 1U] = g_Sc8913_Registers[p_ch->Channel_Id][i / 2U];
  62   2              }
  63   1      
  64   1              if (p_ch->Charger_Flag.Is_ChargingFlag == true)
  65   1              {       /*充电还没有结束*/
  66   2                      if (p_ch->CState != End_Charging)
  67   2                      {
  68   3                              /*累加充电时间*/
  69   3                              p_ch->For_ChargingPara.Time++;
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 36  

  70   3                              /*统计充电电量*/
  71   3                              p_ch->For_ChargingPara.Electricity += p_ch->For_ChargingPara.Current;
  72   3                      }
  73   2              }
  74   1              else
  75   1              { /*清空充电时间和电量*/
  76   2                      p_ch->For_ChargingPara.Time = 0;
  77   2                      p_ch->For_ChargingPara.Electricity = 0;
  78   2              }
  79   1              /*导入数据到上报区*/
  80   1              Report.Voltage = p_ch->For_ChargingPara.Voltage;
  81   1              Report.Current = p_ch->For_ChargingPara.Current;
  82   1              Report.Time = p_ch->For_ChargingPara.Time / 60U;
  83   1              Report.Electricity = p_ch->For_ChargingPara.Electricity * 10.0F / 36.0F; //(*1000/3600)
  84   1              /*上报前台数据*/
  85   1              Dwin_Write(back_addr, (uint8_t *)&Report, sizeof(Report));
  86   1              Set_Charging_State(p_ch->CState, p_ch->Charger_Show_Addr.State_Addr);
  87   1              Set_Charging_Amimation(p_ch->Charger_Flag.Cartoon_Flag, p_ch->Charger_Show_Addr.Animation_Addr);
  88   1              /*上报后台数据*/
  89   1              Dwin_Write(p_ch->Charger_Show_Addr.Back_Para_Addr, (uint8_t *)&p_ch->Bac_ChargingPara, sizeof(p_ch->Bac_C
             -hargingPara));
  90   1              /*上报SC8913内部寄存器数据*/
  91   1              Dwin_Write(param_addr, temp_buf, sizeof(temp_buf));
  92   1              memcpy(&g_Cloud_Buffer[counter* sizeof(Report)] , (uint8_t *)&Report, sizeof(Report));
  93   1              if (++counter == CHANNEL_MAX)
  94   1              {
  95   2                      /*把数据上报到4G模块*/
  96   2                  MOD_46H(SLAVEADDRESS, 0x0000, sizeof(g_Cloud_Buffer) / 2U, sizeof(g_Cloud_Buffer), g_Cloud_Buffer);
  97   2                      counter = 0U;
  98   2              }
  99   1      }
 100          
 101          /*9级优化，速度优先*/
 102          //#pragma OPTIMIZE(9, speed)
 103          /**
 104           * @brief       获取当前通道BAT电流
 105           * @details     轮询处理每个充电通道
 106           * @param       p_ch:当前通道
 107           * @retval      BATCurrent
 108           */
 109          float Get_BAT_Current(Charging_Typedef *const p_ch)
 110          {
 111   1              return READ_IBAT_VALUE(p_ch->Channel_Id, IBAT_VALUE_ADDR);
 112   1      }
 113          
 114          /**
 115           * @brief       获取当前通道BAT电压
 116           * @details     轮询处理每个充电通道
 117           * @param       p_ch:当前通道
 118           * @retval      BATvoltage
 119           */
 120          float Get_BAT_Voltage(Charging_Typedef *const p_ch)
 121          {
 122   1              return ((4U * g_Sc8913_Registers[p_ch->Channel_Id][VBAT_FB_VALUE_ADDR] +
 123   1                         (((g_Sc8913_Registers[p_ch->Channel_Id][VBAT_FB_VALUE_ADDR + 1U]) & 0xc0) >> 6U) + 1.0F) *
 124   1                              2.0F * p_ch->Vbat_Ratio / 1000.0F);
 125   1      }
 126          
 127          /**
 128           * @brief       根据检测到的电压，获取电池区间
 129           * @details     电池区间以单节锂离子电池计算
 130           * @param       p_ch:当前通道
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 37  

 131           * @retval      false/true
 132           */
 133          uint8_t Get_Battery_Range(float persent_voltage)
 134          {
 135   1              uint16_t length = (sizeof(Battery_Interval) / sizeof(float)) / 2U;
 136   1              uint8_t i = 0;
 137   1      
 138   1              for (i = 0; i < length; i++)
 139   1              {
 140   2                      if ((persent_voltage > Battery_Interval[i][0]) && (persent_voltage < Battery_Interval[i][1]))
 141   2                      {
 142   3                              return i;
 143   3                      }
 144   2              }
 145   1              /*不在合理电压区间*/
 146   1              return 4U;
 147   1      }
 148          
 149          /**
 150           * @brief       通过获取当前电池区间，设置SC8913合适的充电参数
 151           * @details     设置好充电参数后，再检测设备(同时获取了电池节数)
 152           * @param       p_ch:当前通道
 153           * @retval      false/true
 154           */
 155          uint8_t Set_Charging_Mode(Charging_Typedef *const p_ch)
 156          {
 157   1              uint8_t ret = false;
 158   1              uint8_t dat = 0;
 159   1      
 160   1              switch (Get_Battery_Range(p_ch->For_ChargingPara.Voltage))
 161   1              {
 162   2              case 0:
 163   2              {
 164   3                      p_ch->Batterry_Numbers = 0x01;
 165   3                      dat = 0x01;
 166   3                      REVISE_REGISTER(p_ch, dat, true, ret);
 167   3              }
 168   2              break;
 169   2              case 1:
 170   2              {
 171   3                      p_ch->Batterry_Numbers = 0x02;
 172   3                      dat = 0x09;
 173   3                      REVISE_REGISTER(p_ch, dat, true, ret);
 174   3              }
 175   2              break;
 176   2              case 2:
 177   2              {
 178   3                      p_ch->Batterry_Numbers = 0x03;
 179   3                      dat = 0x11;
 180   3                      REVISE_REGISTER(p_ch, dat, false, ret);
 181   3              }
 182   2              break;
 183   2              case 3:
 184   2              {
 185   3                      p_ch->Batterry_Numbers = 0x04;
 186   3                      dat = 0x19;
 187   3                      REVISE_REGISTER(p_ch, dat, false, ret);
 188   3              }
 189   2              break;
 190   2              default:
 191   2                      break;
 192   2              }
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 38  

 193   1              return ret;
 194   1      }
 195          
 196          /**
 197           * @brief       获取STATUS寄存器中断位
 198           * @details     产生中断的位会被置1
 199           * @param       p_ch:当前通道;abit:位置
 200           * @retval      true/false
 201           */
 202          /*STATUS: 7:DM_L 6:AC_OK 5:IDENT2 4:IDENT1 3:VBUSSHORT 2:OTP 1:EOC 0:None*/     
 203          uint8_t Get_StatusBit(Charging_Typedef *const p_ch, uint8_t abit)
 204          {       /*获取中断位在STATUS中位置*/
 205   1              uint8_t site = (0x01 << abit);
 206   1              
 207   1              if(site & g_Sc8913_Registers[p_ch->Channel_Id][STATUS_ADDR])
 208   1              {
 209   2                      return true;
 210   2              }
 211   1              else
 212   1              {
 213   2                      return false;
 214   2              }
 215   1      }
 216          
 217          /**
 218           * @brief       检测AC_Ok中断位
 219           * @details     当产生AC_OK中断时，动态跟随AC_DEF位
 220           * @param       p_ch:当前通道
 221           * @retval      true:交流电源接入;false:交流断开,或者VBAT > VBUS
 222           */
 223          uint8_t Set_AcDef(Charging_Typedef *const p_ch)
 224          {
 225   1              uint8_t temp = 0;
 226   1      
 227   1              /*AC_OK位被置为1*/
 228   1              if(Get_StatusBit(p_ch, AC_OK_BIT))
 229   1              {       /*设置AC_DEF位为1:当VCIN < 3 || VBUS < VBAT时，AC_0k = 0*/
 230   2              temp = SET_CTRL0_SET(1U);
 231   2              if(!Sc8913_Write_Register(p_ch->Channel_Id, CTRL0_SET_ADDR, &temp, sizeof(temp)))
 232   2              {       /*错误码*/
 233   3                  return 2U;
 234   3              }
 235   2                      return true;
 236   2              }
 237   1              /*AC_OK位被置为0*/
 238   1              else
 239   1              {       /*清除AC_DEF位为0：当VCIN > 3V, AC_OK = 1; VCIN < 3,AC_ok = 0*/
 240   2              temp = SET_CTRL0_SET(0U);
 241   2              if(!Sc8913_Write_Register(p_ch->Channel_Id, CTRL0_SET_ADDR, &temp, sizeof(temp)))
 242   2              {       /*错误码*/
 243   3                  return 2U;
 244   3              }
 245   2                      return false;
 246   2              }
 247   1      }
 248          
 249          /**
 250           * @brief       充电投票
 251           * @details     轮询处理每个充电通道
 252           * @param       p_ch:当前通道
 253           * @retval      None
 254           */
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 39  

 255          void Charging_Poll(Charging_Typedef *const p_ch)
 256          {
 257   1              /*可以根据返回值确定SC8913是否接入交流电*/
 258   1              Set_AcDef(p_ch);
 259   1              /*读取当前通道BAT电压*/
 260   1              p_ch->For_ChargingPara.Voltage = Get_BAT_Voltage(p_ch);
 261   1              /*读取当前通道BAT电流*/
 262   1              p_ch->For_ChargingPara.Current = Get_BAT_Current(p_ch);
 263   1              /*待机阶段*/
 264   1              if (p_ch->Charger_Flag.Is_ChargingFlag == false)
 265   1              {       /*是否有设备*/
 266   2                      if (Check_Connect(p_ch) == true)
 267   2                      {
 268   3                              p_ch->Charger_Flag.Is_ChargingFlag = true;
 269   3                              p_ch->Charger_Flag.Cartoon_Flag = true;
 270   3                              Get_BackCharging_Parameters(p_ch);
 271   3                      }
 272   2                      else
 273   2                      {
 274   3                              p_ch->CState = stdantby_Mode;
 275   3                      }
 276   2              }
 277   1              else
 278   1              /*充电阶段*/
 279   1              {
 280   2                      /*获得当前电池充电状态*/
 281   2                      Get_NowChargingMode(p_ch);
 282   2                      ChargingStage_Monitor(p_ch);
 283   2              }
 284   1      }
 285          
 286          /**
 287           * @brief       检测是否有设备接入
 288           * @details     轮询处理每个充电通道
 289           * @param       p_ch:当前通道
 290           * @retval      false/true
 291           */
 292          uint8_t Check_Connect(Charging_Typedef *const p_ch)
 293          {
 294   1              static uint8_t mutex[CHANNEL_MAX] = {false, false, false};
 295   1              static uint8_t counts[CHANNEL_MAX] = {0, 0, 0};
 296   1      
 297   1              /*如果已经检测到电压，则设置芯片合适参数*/
 298   1              if (p_ch->For_ChargingPara.Voltage > LOWEST_VOLTAGE)
 299   1              { /*在芯片输出关闭情况下能够检测到电压，说明是电池设备*/
 300   2                      p_ch->Dev_Type = Cell;
 301   2                      /*避免重复设置充电参数*/
 302   2                      if (!mutex[p_ch->Channel_Id])
 303   2                      {
 304   3                              if (!Set_Charging_Mode(p_ch))
 305   3                              {
 306   4                                      return false;
 307   4                              }
 308   3                              /*打开芯片电源输出*/
 309   3                              Set_Sc8913_Stop(p_ch->Channel_Id, Low);
 310   3                              mutex[p_ch->Channel_Id] = true;
 311   3                      }
 312   2              }
 313   1              else /*无电池接入*/
 314   1              {
 315   2                      return false;
 316   2              }
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 40  

 317   1      
 318   1              /*是否检测到电流*/
 319   1              if (p_ch->For_ChargingPara.Current > CHECK_CURRENT)
 320   1              { 
 321   2                      mutex[p_ch->Channel_Id] = false;
 322   2                      return true;
 323   2              }
 324   1              /*接入的设备无需充电*/
 325   1              else
 326   1              {       /*连续检测5s*/
 327   2                      if (++counts[p_ch->Channel_Id] >= OPENTIME)
 328   2                      {
 329   3                              counts[p_ch->Channel_Id] = 0;
 330   3                              /*关闭芯片电源输出*/
 331   3                              Set_Sc8913_Stop(p_ch->Channel_Id, High);
 332   3                              p_ch->CState = End_Charging;
 333   3                              return true;
 334   3                      }
 335   2              }
 336   1      
 337   1              return false;
 338   1      }
 339          
 340          /**
 341           * @brief       计算出当前通道下电池的后台信息
 342           * @details     轮询处理每个充电通道
 343           * @param       p_ch:当前通道
 344           * @retval      None
 345           */
 346          void Get_BackCharging_Parameters(Charging_Typedef *const p_ch)
 347          { 
 348   1              /*涓流目标电压*/
 349   1              p_ch->Bac_ChargingPara.Trickle_Target_Voltage = ONCE_MINVOLTAGE * p_ch->Batterry_Numbers;
 350   1              /*涓流目标电流*/
 351   1              p_ch->Bac_ChargingPara.Trickle_Target_Current = TRICKLE_CURRNET;
 352   1              /*恒流目标电压*/
 353   1              p_ch->Bac_ChargingPara.ConstantCurrent_Target_Voltage = ONCE_FULLVOLTAGE * p_ch->Batterry_Numbers;
 354   1              /*恒流目标电流:利用动态总功率算出恒流电流*/
 355   1              p_ch->Bac_ChargingPara.ConstantCurrent_Target_Current = (IBAT_MAX_CURRENT * ONCE_MAXVOLTAGE) / p_ch->For_
             -ChargingPara.Voltage;
 356   1              /*恒压目标电压*/
 357   1              p_ch->Bac_ChargingPara.ConstantVoltage_Target_Voltage = ONCE_MAXVOLTAGE * p_ch->Batterry_Numbers;
 358   1              /*恒压目标电流*/
 359   1              p_ch->Bac_ChargingPara.ConstantVoltage_Target_Current = CHECK_CURRENT;
 360   1      }
 361          
 362          /**
 363           * @brief       计算出当前通道下电池的后台信息
 364           * @details     轮询处理每个充电通道
 365           * @param       p_ch:当前通道
 366           * @retval      None
 367           */
 368          void Get_NowChargingMode(Charging_Typedef *const p_ch)
 369          {
 370   1              if (p_ch->CState == End_Charging) 
 371   1                      return;
 372   1      
 373   1              if (p_ch->For_ChargingPara.Voltage < LOWEST_VOLTAGE)
 374   1              {
 375   2                      p_ch->CState = stdantby_Mode;
 376   2              }/*当前充电对象电压<=涓流电压*/
 377   1              else if (p_ch->For_ChargingPara.Voltage <= p_ch->Bac_ChargingPara.Trickle_Target_Voltage)
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 41  

 378   1              {
 379   2                      p_ch->CState = Trickle_Mode;
 380   2              }
 381   1              else if (p_ch->For_ChargingPara.Voltage <= p_ch->Bac_ChargingPara.ConstantVoltage_Target_Voltage)
 382   1              {
 383   2                      p_ch->CState = Constant_Current_Mode;
 384   2              }
 385   1              else
 386   1              {
 387   2                      p_ch->CState = Constant_Voltage_Mode;
 388   2              }
 389   1      }
 390          
 391          /**
 392           * @brief       充电阶段监测
 393           * @details     轮询处理每个充电通道
 394           * @param       p_ch:当前通道
 395           * @retval      None
 396           */
 397          void ChargingStage_Monitor(Charging_Typedef *const p_ch)
 398          { 
 399   1              /*是否充电结束*/
 400   1              if(Get_StatusBit(p_ch, EOC_BIT) == true)
 401   1              { /*电池被拔掉也会造成EOC位置1，在确定当前通道是否还有电压*/
 402   2                      if (p_ch->For_ChargingPara.Voltage > LOWEST_VOLTAGE)
 403   2                      { /*认为充电结束*/
 404   3                              p_ch->CState = End_Charging;
 405   3                              /*关闭芯片输出引脚*/
 406   3                              Set_Sc8913_Stop(p_ch->Channel_Id, High);
 407   3                      }
 408   2              }
 409   1              /*由于电流消失而造成的断路*/
 410   1              if (Check_DisConnect(p_ch) == true)
 411   1              {
 412   2                      p_ch->Charger_Flag.Is_ChargingFlag = false;
 413   2                      /*待机*/
 414   2                      p_ch->CState = stdantby_Mode;
 415   2                      p_ch->Dev_Type = No_Device;
 416   2                      /*关闭充电动画*/
 417   2                      p_ch->Charger_Flag.Cartoon_Flag = false;
 418   2              } 
 419   1      }
 420          
 421          /**
 422           * @brief       检测充电设备是否断开连接
 423           * @details     轮询处理每个充电通道
 424           * @param       p_ch:当前通道
 425           * @retval      None
 426           */
 427          uint8_t Check_DisConnect(Charging_Typedef *const p_ch)
 428          {
 429   1              if ((p_ch->For_ChargingPara.Current < CHECK_CURRENT) && (p_ch->For_ChargingPara.Voltage < LOWEST_VOLTAGE)
             -)
 430   1              {
 431   2                      return true;
 432   2              }
 433   1      
 434   1              return false;
 435   1      }
 436          
 437          /**
 438           * @brief       设置充电动画
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 42  

 439           * @details     轮询处理每个通道
 440           * @param       state:状态,addr:地址
 441           * @retval      None
 442           */
 443          void Set_Charging_Amimation(uint8_t state, uint32_t addr)
 444          {
 445   1              uint16_t temp_value = 0x0000;
 446   1      
 447   1              if (state == true)
 448   1              {
 449   2                      temp_value = 0x01;
 450   2              }
 451   1      
 452   1              Dwin_Write(addr, (uint8_t *)&temp_value, sizeof(temp_value));
 453   1      }
 454          
 455          /**
 456           * @brief       设置充电状态
 457           * @details     轮询处理每个通道
 458           * @param       state:状态,addr:地址
 459           * @retval      None
 460           */
 461          void Set_Charging_State(Charging_State state, uint32_t addr)
 462          {
 463   1              uint16_t temp_value = (uint8_t)state;
 464   1              /*把充电图标地址和状态对应起来*/
 465   1              Dwin_Write(addr, (uint8_t *)&temp_value, sizeof(temp_value));
 466   1      }
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 43  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION Com0062 (BEGIN)
0000         L?0099:
0000         L?0100:
0000 900000      R     MOV     DPTR,#p_ch
0003         L?0101:
0003 E0                MOVX    A,@DPTR
0004 FB                MOV     R3,A
0005 A3                INC     DPTR
0006 E0                MOVX    A,@DPTR
0007 FA                MOV     R2,A
0008 A3                INC     DPTR
0009 E0                MOVX    A,@DPTR
000A F9                MOV     R1,A
000B 22                RET     
000C         L?0102:
000C 743A              MOV     A,#03AH
000E         L?0103:
000E 900000      R     MOV     DPTR,#dat
0011         L?0104:
0011 F0                MOVX    @DPTR,A
0012 120000      E     LCALL   ?C?CLDPTR
0015 7A00        R     MOV     R2,#HIGH dat
0017 7900        R     MOV     R1,#LOW dat
0019         L?0105:
0019 FF                MOV     R7,A
001A 7B01              MOV     R3,#01H
001C         L?0106:
001C 900000      E     MOV     DPTR,#?_Sc8913_Write_Register?BYTE+05H
001F 7401              MOV     A,#01H
0021 F0                MOVX    @DPTR,A
0022 22                RET     
0023         L?0107:
0023         L?0108:
0023 EB                MOV     A,R3
0024 F0                MOVX    @DPTR,A
0025 A3                INC     DPTR
0026 EA                MOV     A,R2
0027 F0                MOVX    @DPTR,A
0028 A3                INC     DPTR
0029 E9                MOV     A,R1
002A F0                MOVX    @DPTR,A
002B 22                RET     
002C         L?0109:
002C         L?0110:
002C 900004            MOV     DPTR,#04H
002F 120000      E     LCALL   ?C?LLDOPTR
0032 E4                CLR     A
0033 FB                MOV     R3,A
0034 FA                MOV     R2,A
0035 F9                MOV     R1,A
0036 7840              MOV     R0,#040H
0038 74F0              MOV     A,#0F0H
003A 020000      E     LJMP    ?C?FPCMP
003D         L?0111:
003D A3                INC     DPTR
003E A3                INC     DPTR
003F E0                MOVX    A,@DPTR
0040 FE                MOV     R6,A
0041 A3                INC     DPTR
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 44  

0042 E0                MOVX    A,@DPTR
0043 FF                MOV     R7,A
0044 7B01              MOV     R3,#01H
0046         L?0112:
0046 900000      E     MOV     DPTR,#?_Dwin_Write?BYTE+05H
0049 E4                CLR     A
004A F0                MOVX    @DPTR,A
004B A3                INC     DPTR
004C 22                RET     
004D         L?0113:
004D F583              MOV     DPH,A
004F E0                MOVX    A,@DPTR
0050 FC                MOV     R4,A
0051 A3                INC     DPTR
0052 E0                MOVX    A,@DPTR
0053 FD                MOV     R5,A
0054 A3                INC     DPTR
0055 E0                MOVX    A,@DPTR
0056 FE                MOV     R6,A
0057 A3                INC     DPTR
0058 E0                MOVX    A,@DPTR
0059 FF                MOV     R7,A
005A 900000      R     MOV     DPTR,#persent_voltage
005D E0                MOVX    A,@DPTR
005E F8                MOV     R0,A
005F A3                INC     DPTR
0060 E0                MOVX    A,@DPTR
0061 F9                MOV     R1,A
0062 A3                INC     DPTR
0063 E0                MOVX    A,@DPTR
0064 FA                MOV     R2,A
0065 A3                INC     DPTR
0066 E0                MOVX    A,@DPTR
0067 FB                MOV     R3,A
0068 74F0              MOV     A,#0F0H
006A 020000      E     LJMP    ?C?FPCMP
006D         L?0114:
006D F8                MOV     R0,A
006E E6                MOV     A,@R0
006F 75F004            MOV     B,#04H
0072 A4                MUL     AB
0073 2D                ADD     A,R5
0074 FD                MOV     R5,A
0075 EC                MOV     A,R4
0076 35F0              ADDC    A,B
0078 FC                MOV     R4,A
0079 E4                CLR     A
007A 120000      E     LCALL   ?C?FCASTI
007D E4                CLR     A
007E FB                MOV     R3,A
007F FA                MOV     R2,A
0080 7980              MOV     R1,#080H
0082 783F              MOV     R0,#03FH
0084 120000      E     LCALL   ?C?FPADD
0087 E4                CLR     A
0088 FB                MOV     R3,A
0089 FA                MOV     R2,A
008A 22                RET     
008B         L?0115:
008B         L?0116:
008B 120000      E     LCALL   ?C?CLDPTR
008E 2400        R     ADD     A,#LOW mutex
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 45  

0090 F582              MOV     DPL,A
0092 E4                CLR     A
0093 3400        R     ADDC    A,#HIGH mutex
0095 F583              MOV     DPH,A
0097 22                RET     
0098         L?0117:
0098 900008            MOV     DPTR,#08H
009B 120000      E     LCALL   ?C?LLDOPTR
009E 7B9A              MOV     R3,#09AH
00A0 7A99              MOV     R2,#099H
00A2 7999              MOV     R1,#099H
00A4 783E              MOV     R0,#03EH
00A6 74F0              MOV     A,#0F0H
00A8 020000      E     LJMP    ?C?FPCMP
00AB         L?0118:
00AB         L?0119:
00AB 900002            MOV     DPTR,#02H
00AE 120000      E     LCALL   ?C?CLDOPTR
00B1 FC                MOV     R4,A
00B2 E4                CLR     A
00B3 020000      E     LJMP    ?C?FCASTC
00B6         L?0120:
00B6 F8                MOV     R0,A
00B7 E6                MOV     A,@R0
00B8 54C0              ANL     A,#0C0H
00BA FE                MOV     R6,A
00BB C4                SWAP    A
00BC 13                RRC     A
00BD 13                RRC     A
00BE 5403              ANL     A,#03H
00C0 FD                MOV     R5,A
00C1 7C00              MOV     R4,#00H
00C3 EF                MOV     A,R7
00C4 75F01C            MOV     B,#01CH
00C7 A4                MUL     AB
00C8 22                RET     
00C9         L?0121:
00C9 7D01              MOV     R5,#01H
00CB 7BFF              MOV     R3,#0FFH
00CD 7E00              MOV     R6,#00H
00CF 020000      E     LJMP    ?C?COPY
00D2         L?0122:
00D2         L?0123:
00D2 900000      R     MOV     DPTR,#ret
00D5 7401              MOV     A,#01H
00D7 F0                MOVX    @DPTR,A
00D8 22                RET     
00D9         L?0124:
00D9 900002            MOV     DPTR,#02H
00DC         L?0125:
00DC 120000      E     LCALL   ?C?CSTOPTR
00DF 900000      R     MOV     DPTR,#dat
00E2 22                RET     
00E3         L?0126:
00E3 120000      E     LCALL   ?C?LLDOPTR
00E6 900004            MOV     DPTR,#04H
00E9 120000      E     LCALL   ?C?LLDOPTR0
00EC 74F0              MOV     A,#0F0H
00EE 020000      E     LJMP    ?C?FPCMP
00F1         L?0127:
00F1         L?0128:
00F1 7840              MOV     R0,#040H
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 46  

00F3 120000      E     LCALL   ?C?FPMUL
00F6 900000      R     MOV     DPTR,#p_ch
00F9 22                RET     
00FA         L?0131:
00FA 7403              MOV     A,#03H
00FC         L?0132:
00FC 900003            MOV     DPTR,#03H
00FF 020000      E     LJMP    ?C?CSTOPTR
0102         L?0133:
0102         L?0134:
0102 900003            MOV     DPTR,#03H
0105 020000      E     LJMP    ?C?CLDOPTR
0108         L?0135:
0108 2400        R     ADD     A,#LOW counts
010A F582              MOV     DPL,A
010C E4                CLR     A
010D 3400        R     ADDC    A,#HIGH counts
010F F583              MOV     DPH,A
0111 22                RET     
             ; FUNCTION Com0062 (END)

             ; FUNCTION _Report_ChargerInfo (BEGIN)
                                           ; SOURCE LINE # 49
0000 900000      R     MOV     DPTR,#p_ch
0003 120000      R     LCALL   L?0107
                                           ; SOURCE LINE # 50
                                           ; SOURCE LINE # 51
0006 7800        R     MOV     R0,#LOW Report
0008 7C00        R     MOV     R4,#HIGH Report
000A 7A00        R     MOV     R2,#HIGH _?ix1000
000C 7900        R     MOV     R1,#LOW _?ix1000
000E 7F10              MOV     R7,#010H
0010 120000      R     LCALL   L?0121
                                           ; SOURCE LINE # 52
0013 120000      R     LCALL   L?0099
0016 120000      E     LCALL   ?C?CLDPTR
0019 75F020            MOV     B,#020H
001C A4                MUL     AB
001D FD                MOV     R5,A
001E ACF0              MOV     R4,B
0020 2420              ADD     A,#020H
0022 FE                MOV     R6,A
0023 EC                MOV     A,R4
0024 3410              ADDC    A,#010H
0026 900000      R     MOV     DPTR,#back_addr
0029 F0                MOVX    @DPTR,A
002A A3                INC     DPTR
002B CE                XCH     A,R6
002C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 53
002D E4                CLR     A
002E 2D                ADD     A,R5
002F FE                MOV     R6,A
0030 EC                MOV     A,R4
0031 3430              ADDC    A,#030H
0033 A3                INC     DPTR
0034 F0                MOVX    @DPTR,A
0035 A3                INC     DPTR
0036 CE                XCH     A,R6
0037 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 54
0038 7800        R     MOV     R0,#LOW temp_buf
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 47  

003A 7C00        R     MOV     R4,#HIGH temp_buf
003C 7A00        R     MOV     R2,#HIGH _?ix1001
003E 7900        R     MOV     R1,#LOW _?ix1001
0040 7F38              MOV     R7,#038H
0042 120000      R     LCALL   L?0121
                                           ; SOURCE LINE # 55
;---- Variable 'i' assigned to Register 'R5' ----
0045 E4                CLR     A
0046 FD                MOV     R5,A
                                           ; SOURCE LINE # 58
0047         ?C0001:
0047 ED                MOV     A,R5
0048 FF                MOV     R7,A
0049 7E00              MOV     R6,#00H
004B C3                CLR     C
004C 9438              SUBB    A,#038H
004E EE                MOV     A,R6
004F 9400              SUBB    A,#00H
0051 5031              JNC     ?C0002
                                           ; SOURCE LINE # 59
                                           ; SOURCE LINE # 60
0053 7400        R     MOV     A,#LOW temp_buf
0055 2D                ADD     A,R5
0056 F582              MOV     DPL,A
0058 E4                CLR     A
0059 3400        R     ADDC    A,#HIGH temp_buf
005B F583              MOV     DPH,A
005D E4                CLR     A
005E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 61
005F C3                CLR     C
0060 13                RRC     A
0061 EF                MOV     A,R7
0062 13                RRC     A
0063 FF                MOV     R7,A
0064 120000      R     LCALL   L?0099
0067 120000      E     LCALL   ?C?CLDPTR
006A 75F01C            MOV     B,#01CH
006D A4                MUL     AB
006E 2400        E     ADD     A,#LOW g_Sc8913_Registers
0070 2F                ADD     A,R7
0071 F8                MOV     R0,A
0072 E6                MOV     A,@R0
0073 FF                MOV     R7,A
0074 7400        R     MOV     A,#LOW temp_buf+01H
0076 2D                ADD     A,R5
0077 F582              MOV     DPL,A
0079 E4                CLR     A
007A 3400        R     ADDC    A,#HIGH temp_buf+01H
007C F583              MOV     DPH,A
007E EF                MOV     A,R7
007F F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 62
0080 0D                INC     R5
0081 0D                INC     R5
0082 80C3              SJMP    ?C0001
0084         ?C0002:
                                           ; SOURCE LINE # 64
0084 120000      R     LCALL   L?0100
0087 900038            MOV     DPTR,#038H
008A 120000      E     LCALL   ?C?CLDOPTR
008D 6401              XRL     A,#01H
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 48  

008F 7047              JNZ     ?C0004
                                           ; SOURCE LINE # 65
                                           ; SOURCE LINE # 66
0091 120000      R     LCALL   L?0133
0094 6403              XRL     A,#03H
0096 6057              JZ      ?C0006
                                           ; SOURCE LINE # 67
                                           ; SOURCE LINE # 69
0098 90000C            MOV     DPTR,#0CH
009B 120000      E     LCALL   ?C?LLDOPTR
009E EF                MOV     A,R7
009F 2401              ADD     A,#01H
00A1 FF                MOV     R7,A
00A2 E4                CLR     A
00A3 3E                ADDC    A,R6
00A4 FE                MOV     R6,A
00A5 E4                CLR     A
00A6 3D                ADDC    A,R5
00A7 FD                MOV     R5,A
00A8 E4                CLR     A
00A9 3C                ADDC    A,R4
00AA FC                MOV     R4,A
00AB 90000C            MOV     DPTR,#0CH
00AE 120000      E     LCALL   ?C?LSTOPTR
                                           ; SOURCE LINE # 71
00B1 E9                MOV     A,R1
00B2 2410              ADD     A,#010H
00B4 F9                MOV     R1,A
00B5 E4                CLR     A
00B6 3A                ADDC    A,R2
00B7 FA                MOV     R2,A
00B8 C003              PUSH    AR3
00BA C002              PUSH    AR2
00BC C001              PUSH    AR1
00BE 120000      E     LCALL   ?C?LLDPTR
00C1 120000      R     LCALL   L?0100
00C4 900008            MOV     DPTR,#08H
00C7 120000      E     LCALL   ?C?LLDOPTR0
00CA 120000      E     LCALL   ?C?FPADD
00CD D001              POP     AR1
00CF D002              POP     AR2
00D1 D003              POP     AR3
00D3 120000      E     LCALL   ?C?LSTPTR
                                           ; SOURCE LINE # 72
                                           ; SOURCE LINE # 73
00D6 8017              SJMP    ?C0006
00D8         ?C0004:
                                           ; SOURCE LINE # 75
                                           ; SOURCE LINE # 76
00D8 120000      R     LCALL   L?0100
00DB 90000C            MOV     DPTR,#0CH
00DE 120000      E     LCALL   ?C?LSTKOPTR
00E1 00                DB      00H
00E2 00                DB      00H
00E3 00                DB      00H
00E4 00                DB      00H
                                           ; SOURCE LINE # 77
00E5 900010            MOV     DPTR,#010H
00E8 120000      E     LCALL   ?C?LSTKOPTR
00EB 00                DB      00H
00EC 00                DB      00H
00ED 00                DB      00H
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 49  

00EE 00                DB      00H
                                           ; SOURCE LINE # 78
00EF         ?C0006:
                                           ; SOURCE LINE # 80
00EF 120000      R     LCALL   L?0100
00F2 900004            MOV     DPTR,#04H
00F5 120000      E     LCALL   ?C?LLDOPTR
00F8 900000      R     MOV     DPTR,#Report
00FB 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 81
00FE 900008            MOV     DPTR,#08H
0101 120000      E     LCALL   ?C?LLDOPTR
0104 900000      R     MOV     DPTR,#Report+04H
0107 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 82
010A 90000C            MOV     DPTR,#0CH
010D 120000      E     LCALL   ?C?LLDOPTR
0110 E4                CLR     A
0111 7B3C              MOV     R3,#03CH
0113 FA                MOV     R2,A
0114 F9                MOV     R1,A
0115 F8                MOV     R0,A
0116 120000      E     LCALL   ?C?ULDIV
0119 900000      R     MOV     DPTR,#Report+08H
011C 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 83
011F 120000      R     LCALL   L?0100
0122 900010            MOV     DPTR,#010H
0125 120000      E     LCALL   ?C?LLDOPTR
0128 E4                CLR     A
0129 FB                MOV     R3,A
012A FA                MOV     R2,A
012B 7920              MOV     R1,#020H
012D 7841              MOV     R0,#041H
012F 120000      E     LCALL   ?C?FPMUL
0132 E4                CLR     A
0133 FB                MOV     R3,A
0134 FA                MOV     R2,A
0135 7910              MOV     R1,#010H
0137 7842              MOV     R0,#042H
0139 120000      E     LCALL   ?C?FPDIV
013C 900000      R     MOV     DPTR,#Report+0CH
013F 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 85
0142 900000      R     MOV     DPTR,#back_addr
0145 E0                MOVX    A,@DPTR
0146 FE                MOV     R6,A
0147 A3                INC     DPTR
0148 E0                MOVX    A,@DPTR
0149 FF                MOV     R7,A
014A 7B01              MOV     R3,#01H
014C 7A00        R     MOV     R2,#HIGH Report
014E 7900        R     MOV     R1,#LOW Report
0150 120000      R     LCALL   L?0112
0153 7410              MOV     A,#010H
0155 F0                MOVX    @DPTR,A
0156 120000      E     LCALL   _Dwin_Write
                                           ; SOURCE LINE # 86
0159 120000      R     LCALL   L?0100
015C 120000      R     LCALL   L?0133
015F FF                MOV     R7,A
0160 C007              PUSH    AR7
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 50  

0162 900034            MOV     DPTR,#034H
0165 120000      E     LCALL   ?C?LLDOPTR
0168 900000      R     MOV     DPTR,#?_Set_Charging_State?BYTE+01H
016B 120000      E     LCALL   ?C?LSTXDATA
016E D007              POP     AR7
0170 120000      R     LCALL   _Set_Charging_State
                                           ; SOURCE LINE # 87
0173 120000      R     LCALL   L?0100
0176 900039            MOV     DPTR,#039H
0179 120000      E     LCALL   ?C?CLDOPTR
017C FF                MOV     R7,A
017D C007              PUSH    AR7
017F 900030            MOV     DPTR,#030H
0182 120000      E     LCALL   ?C?LLDOPTR
0185 900000      R     MOV     DPTR,#?_Set_Charging_Amimation?BYTE+01H
0188 120000      E     LCALL   ?C?LSTXDATA
018B D007              POP     AR7
018D 120000      R     LCALL   _Set_Charging_Amimation
                                           ; SOURCE LINE # 89
0190 120000      R     LCALL   L?0100
0193 90002C            MOV     DPTR,#02CH
0196 120000      E     LCALL   ?C?LLDOPTR
0199 E9                MOV     A,R1
019A 2414              ADD     A,#014H
019C F9                MOV     R1,A
019D E4                CLR     A
019E 3A                ADDC    A,R2
019F FA                MOV     R2,A
01A0 120000      R     LCALL   L?0112
01A3 7418              MOV     A,#018H
01A5 F0                MOVX    @DPTR,A
01A6 120000      E     LCALL   _Dwin_Write
                                           ; SOURCE LINE # 91
01A9 900000      R     MOV     DPTR,#param_addr
01AC E0                MOVX    A,@DPTR
01AD FE                MOV     R6,A
01AE A3                INC     DPTR
01AF E0                MOVX    A,@DPTR
01B0 FF                MOV     R7,A
01B1 7B01              MOV     R3,#01H
01B3 7A00        R     MOV     R2,#HIGH temp_buf
01B5 7900        R     MOV     R1,#LOW temp_buf
01B7 120000      R     LCALL   L?0112
01BA 7438              MOV     A,#038H
01BC F0                MOVX    @DPTR,A
01BD 120000      E     LCALL   _Dwin_Write
                                           ; SOURCE LINE # 92
01C0 900000      R     MOV     DPTR,#counter
01C3 E0                MOVX    A,@DPTR
01C4 75F010            MOV     B,#010H
01C7 A4                MUL     AB
01C8 2400        R     ADD     A,#LOW g_Cloud_Buffer
01CA F9                MOV     R1,A
01CB 7400        R     MOV     A,#HIGH g_Cloud_Buffer
01CD 35F0              ADDC    A,B
01CF A801              MOV     R0,AR1
01D1 FC                MOV     R4,A
01D2 7D01              MOV     R5,#01H
01D4 7B01              MOV     R3,#01H
01D6 7A00        R     MOV     R2,#HIGH Report
01D8 7900        R     MOV     R1,#LOW Report
01DA 7E00              MOV     R6,#00H
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 51  

01DC 7F10              MOV     R7,#010H
01DE 120000      E     LCALL   ?C?COPY
                                           ; SOURCE LINE # 93
01E1 900000      R     MOV     DPTR,#counter
01E4 E0                MOVX    A,@DPTR
01E5 04                INC     A
01E6 F0                MOVX    @DPTR,A
01E7 6403              XRL     A,#03H
01E9 7023              JNZ     ?C0008
                                           ; SOURCE LINE # 94
                                           ; SOURCE LINE # 96
01EB 900000      E     MOV     DPTR,#?_MOD_46H?BYTE+05H
01EE 7430              MOV     A,#030H
01F0 F0                MOVX    @DPTR,A
01F1 A3                INC     DPTR
01F2 7401              MOV     A,#01H
01F4 F0                MOVX    @DPTR,A
01F5 A3                INC     DPTR
01F6 7400        R     MOV     A,#HIGH g_Cloud_Buffer
01F8 F0                MOVX    @DPTR,A
01F9 A3                INC     DPTR
01FA 7400        R     MOV     A,#LOW g_Cloud_Buffer
01FC F0                MOVX    @DPTR,A
01FD 7B18              MOV     R3,#018H
01FF 7A00              MOV     R2,#00H
0201 E4                CLR     A
0202 FD                MOV     R5,A
0203 FC                MOV     R4,A
0204 7F02              MOV     R7,#02H
0206 120000      E     LCALL   _MOD_46H
                                           ; SOURCE LINE # 97
0209 E4                CLR     A
020A 900000      R     MOV     DPTR,#counter
020D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 98
                                           ; SOURCE LINE # 99
020E         ?C0008:
020E 22                RET     
             ; FUNCTION _Report_ChargerInfo (END)

             ; FUNCTION _Get_BAT_Current (BEGIN)
                                           ; SOURCE LINE # 109
;---- Variable 'p_ch' assigned to Register 'R1/R2/R3' ----
                                           ; SOURCE LINE # 110
                                           ; SOURCE LINE # 111
0000 120000      E     LCALL   ?C?CLDPTR
0003 FF                MOV     R7,A
0004 75F01C            MOV     B,#01CH
0007 A4                MUL     AB
0008 2400        E     ADD     A,#LOW g_Sc8913_Registers+014H
000A 120000      R     LCALL   L?0120
000D 2400        E     ADD     A,#LOW g_Sc8913_Registers+013H
000F 120000      R     LCALL   L?0114
0012 7916              MOV     R1,#016H
0014 7844              MOV     R0,#044H
0016 120000      E     LCALL   ?C?FPDIV
0019 E4                CLR     A
001A FB                MOV     R3,A
001B FA                MOV     R2,A
001C 7940              MOV     R1,#040H
001E 7841              MOV     R0,#041H
0020 020000      E     LJMP    ?C?FPMUL
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 52  

             ; FUNCTION _Get_BAT_Current (END)

             ; FUNCTION _Get_BAT_Voltage (BEGIN)
                                           ; SOURCE LINE # 120
0000 900000      R     MOV     DPTR,#p_ch
0003 120000      R     LCALL   L?0107
                                           ; SOURCE LINE # 121
                                           ; SOURCE LINE # 122
0006 900000      R     MOV     DPTR,#p_ch
0009 120000      R     LCALL   L?0101
000C 120000      E     LCALL   ?C?CLDPTR
000F FF                MOV     R7,A
0010 75F01C            MOV     B,#01CH
0013 A4                MUL     AB
0014 2400        E     ADD     A,#LOW g_Sc8913_Registers+010H
0016 120000      R     LCALL   L?0120
0019 2400        E     ADD     A,#LOW g_Sc8913_Registers+0FH
001B 120000      R     LCALL   L?0114
001E F9                MOV     R1,A
001F 7840              MOV     R0,#040H
0021 120000      E     LCALL   ?C?FPMUL
0024 900000      R     MOV     DPTR,#p_ch
0027 120000      R     LCALL   L?0101
002A 90003B            MOV     DPTR,#03BH
002D 120000      E     LCALL   ?C?LLDOPTR0
0030 120000      E     LCALL   ?C?FPMUL
0033 E4                CLR     A
0034 FB                MOV     R3,A
0035 FA                MOV     R2,A
0036 797A              MOV     R1,#07AH
0038 7844              MOV     R0,#044H
003A 020000      E     LJMP    ?C?FPDIV
             ; FUNCTION _Get_BAT_Voltage (END)

             ; FUNCTION _Get_Battery_Range (BEGIN)
                                           ; SOURCE LINE # 133
0000 900000      R     MOV     DPTR,#persent_voltage
0003 120000      E     LCALL   ?C?LSTXDATA
                                           ; SOURCE LINE # 134
                                           ; SOURCE LINE # 135
0006 900000      R     MOV     DPTR,#length
0009 E4                CLR     A
000A F0                MOVX    @DPTR,A
000B A3                INC     DPTR
000C 7404              MOV     A,#04H
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 136
000F E4                CLR     A
0010 A3                INC     DPTR
0011 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 138
0012 F0                MOVX    @DPTR,A
0013         ?C0011:
0013 900000      R     MOV     DPTR,#i
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 FD                MOV     R5,A
0019 D3                SETB    C
001A 900000      R     MOV     DPTR,#length+01H
001D E0                MOVX    A,@DPTR
001E 9D                SUBB    A,R5
001F 900000      R     MOV     DPTR,#length
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 53  

0022 E0                MOVX    A,@DPTR
0023 9400              SUBB    A,#00H
0025 4036              JC      ?C0012
                                           ; SOURCE LINE # 139
                                           ; SOURCE LINE # 140
0027 EF                MOV     A,R7
0028 75F008            MOV     B,#08H
002B A4                MUL     AB
002C 2400        R     ADD     A,#LOW Battery_Interval
002E F582              MOV     DPL,A
0030 E4                CLR     A
0031 3400        R     ADDC    A,#HIGH Battery_Interval
0033 120000      R     LCALL   L?0113
0036 601C              JZ      ?C0013
0038 401A              JC      ?C0013
003A 900000      R     MOV     DPTR,#i
003D E0                MOVX    A,@DPTR
003E 75F008            MOV     B,#08H
0041 A4                MUL     AB
0042 2400        R     ADD     A,#LOW Battery_Interval+04H
0044 F582              MOV     DPL,A
0046 E4                CLR     A
0047 3400        R     ADDC    A,#HIGH Battery_Interval+04H
0049 120000      R     LCALL   L?0113
004C 5006              JNC     ?C0013
                                           ; SOURCE LINE # 141
                                           ; SOURCE LINE # 142
004E 900000      R     MOV     DPTR,#i
0051 E0                MOVX    A,@DPTR
0052 FF                MOV     R7,A
0053 22                RET     
                                           ; SOURCE LINE # 143
                                           ; SOURCE LINE # 144
0054         ?C0013:
0054 900000      R     MOV     DPTR,#i
0057 E0                MOVX    A,@DPTR
0058 04                INC     A
0059 F0                MOVX    @DPTR,A
005A 020000      R     LJMP    ?C0011
005D         ?C0012:
                                           ; SOURCE LINE # 146
005D 7F04              MOV     R7,#04H
                                           ; SOURCE LINE # 147
005F         ?C0015:
005F 22                RET     
             ; FUNCTION _Get_Battery_Range (END)

             ; FUNCTION _Set_Charging_Mode (BEGIN)
                                           ; SOURCE LINE # 155
0000 900000      R     MOV     DPTR,#p_ch
0003 120000      R     LCALL   L?0108
                                           ; SOURCE LINE # 156
                                           ; SOURCE LINE # 157
0006 E4                CLR     A
0007 A3                INC     DPTR
0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 158
0009 A3                INC     DPTR
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 160
000B 900000      R     MOV     DPTR,#p_ch
000E 120000      R     LCALL   L?0101
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 54  

0011 900004            MOV     DPTR,#04H
0014 120000      E     LCALL   ?C?LLDOPTR
0017 120000      R     LCALL   _Get_Battery_Range
001A EF                MOV     A,R7
001B 14                DEC     A
001C 6049              JZ      ?C0025
001E 14                DEC     A
001F 607C              JZ      ?C0033
0021 14                DEC     A
0022 7003              JNZ     $ + 5H
0024 020000      R     LJMP    ?C0041
0027 2403              ADD     A,#03H
0029 6003              JZ      $ + 5H
002B 020000      R     LJMP    ?C0016
                                           ; SOURCE LINE # 161
                                           ; SOURCE LINE # 162
002E         ?C0017:
                                           ; SOURCE LINE # 163
                                           ; SOURCE LINE # 164
002E 900000      R     MOV     DPTR,#p_ch
0031 120000      R     LCALL   L?0101
0034 900002            MOV     DPTR,#02H
0037 7401              MOV     A,#01H
0039 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 165
003C 7401              MOV     A,#01H
                                           ; SOURCE LINE # 166
003E 120000      R     LCALL   L?0103
0041 120000      R     LCALL   L?0129
0044 6003              JZ      ?C0021
0046 120000      R     LCALL   L?0122
0049         ?C0021:
0049 900000      R     MOV     DPTR,#p_ch
004C 120000      R     LCALL   L?0101
004F 90003B            MOV     DPTR,#03BH
0052 120000      E     LCALL   ?C?LSTKOPTR
0055 40                DB      040H
0056 A0                DB      0A0H
0057 00                DB      00H
0058 00                DB      00H
0059 120000      R     LCALL   L?0102
005C 120000      R     LCALL   L?0130
005F 7003              JNZ     $ + 5H
0061 020000      R     LJMP    ?C0016
                                           ; SOURCE LINE # 167
                                           ; SOURCE LINE # 168
0064 020000      R     LJMP    ?C0094
                                           ; SOURCE LINE # 169
0067         ?C0025:
                                           ; SOURCE LINE # 170
                                           ; SOURCE LINE # 171
0067 900000      R     MOV     DPTR,#p_ch
006A 120000      R     LCALL   L?0101
006D 7402              MOV     A,#02H
                                           ; SOURCE LINE # 172
006F 120000      R     LCALL   L?0124
0072 7409              MOV     A,#09H
                                           ; SOURCE LINE # 173
0074 120000      R     LCALL   L?0104
0077 120000      R     LCALL   L?0129
007A 6003              JZ      ?C0029
007C 120000      R     LCALL   L?0122
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 55  

007F         ?C0029:
007F 900000      R     MOV     DPTR,#p_ch
0082 120000      R     LCALL   L?0101
0085 90003B            MOV     DPTR,#03BH
0088 120000      E     LCALL   ?C?LSTKOPTR
008B 40                DB      040H
008C A0                DB      0A0H
008D 00                DB      00H
008E 00                DB      00H
008F 120000      R     LCALL   L?0102
0092 120000      R     LCALL   L?0130
0095 7003              JNZ     $ + 5H
0097 020000      R     LJMP    ?C0016
009A         ?C0092:
                                           ; SOURCE LINE # 174
                                           ; SOURCE LINE # 175
009A 020000      R     LJMP    ?C0094
                                           ; SOURCE LINE # 176
009D         ?C0033:
                                           ; SOURCE LINE # 177
                                           ; SOURCE LINE # 178
009D 900000      R     MOV     DPTR,#p_ch
00A0 120000      R     LCALL   L?0101
00A3 7403              MOV     A,#03H
                                           ; SOURCE LINE # 179
00A5 120000      R     LCALL   L?0124
00A8 7411              MOV     A,#011H
                                           ; SOURCE LINE # 180
00AA 120000      R     LCALL   L?0104
00AD E4                CLR     A
00AE FD                MOV     R5,A
00AF 120000      E     LCALL   _Sc8913_Write_Register
00B2 EF                MOV     A,R7
00B3 6003              JZ      ?C0038
00B5 120000      R     LCALL   L?0123
00B8         ?C0038:
00B8 900000      R     MOV     DPTR,#p_ch
00BB 120000      R     LCALL   L?0101
00BE 90003B            MOV     DPTR,#03BH
00C1 120000      E     LCALL   ?C?LSTKOPTR
00C4 41                DB      041H
00C5 48                DB      048H
00C6 00                DB      00H
00C7 00                DB      00H
00C8 900000      R     MOV     DPTR,#dat
00CB 7438              MOV     A,#038H
00CD 120000      R     LCALL   L?0104
00D0 7D08              MOV     R5,#08H
00D2 120000      E     LCALL   _Sc8913_Write_Register
00D5 EF                MOV     A,R7
00D6 6043              JZ      ?C0016
00D8         ?C0093:
                                           ; SOURCE LINE # 181
                                           ; SOURCE LINE # 182
00D8 803E              SJMP    ?C0094
                                           ; SOURCE LINE # 183
00DA         ?C0041:
                                           ; SOURCE LINE # 184
                                           ; SOURCE LINE # 185
00DA 900000      R     MOV     DPTR,#p_ch
00DD 120000      R     LCALL   L?0101
00E0 900002            MOV     DPTR,#02H
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 56  

00E3 7404              MOV     A,#04H
                                           ; SOURCE LINE # 186
00E5 120000      R     LCALL   L?0125
00E8 7419              MOV     A,#019H
                                           ; SOURCE LINE # 187
00EA 120000      R     LCALL   L?0104
00ED E4                CLR     A
00EE FD                MOV     R5,A
00EF 120000      E     LCALL   _Sc8913_Write_Register
00F2 EF                MOV     A,R7
00F3 6003              JZ      ?C0046
00F5 120000      R     LCALL   L?0123
00F8         ?C0046:
00F8 900000      R     MOV     DPTR,#p_ch
00FB 120000      R     LCALL   L?0101
00FE 90003B            MOV     DPTR,#03BH
0101 120000      E     LCALL   ?C?LSTKOPTR
0104 41                DB      041H
0105 48                DB      048H
0106 00                DB      00H
0107 00                DB      00H
0108 900000      R     MOV     DPTR,#dat
010B 7438              MOV     A,#038H
010D 120000      R     LCALL   L?0104
0110 7D08              MOV     R5,#08H
0112 120000      E     LCALL   _Sc8913_Write_Register
0115 EF                MOV     A,R7
0116 6003              JZ      ?C0016
0118         ?C0094:
0118 120000      R     LCALL   L?0123
                                           ; SOURCE LINE # 188
                                           ; SOURCE LINE # 189
                                           ; SOURCE LINE # 190
                                           ; SOURCE LINE # 191
                                           ; SOURCE LINE # 192
011B         ?C0016:
                                           ; SOURCE LINE # 193
011B 900000      R     MOV     DPTR,#ret
011E E0                MOVX    A,@DPTR
011F FF                MOV     R7,A
                                           ; SOURCE LINE # 194
0120 22                RET     
0121         L?0129:
0121 E4                CLR     A
0122 FD                MOV     R5,A
0123 120000      E     LCALL   _Sc8913_Write_Register
0126 EF                MOV     A,R7
0127 22                RET     
0128         L?0130:
0128 7D08              MOV     R5,#08H
012A 120000      E     LCALL   _Sc8913_Write_Register
012D EF                MOV     A,R7
012E 22                RET     
             ; FUNCTION _Set_Charging_Mode (END)

             ; FUNCTION _Get_StatusBit (BEGIN)
                                           ; SOURCE LINE # 203
;---- Variable 'abit' assigned to Register 'R5' ----
;---- Variable 'p_ch' assigned to Register 'R1/R2/R3' ----
                                           ; SOURCE LINE # 204
                                           ; SOURCE LINE # 205
0000 AF05              MOV     R7,AR5
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 57  

0002 A807              MOV     R0,AR7
0004 7401              MOV     A,#01H
0006 08                INC     R0
0007 8002              SJMP    ?C0091
0009         ?C0090:
0009 C3                CLR     C
000A 33                RLC     A
000B         ?C0091:
000B D8FC              DJNZ    R0,?C0090
000D FF                MOV     R7,A
;---- Variable 'site' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 207
000E 120000      E     LCALL   ?C?CLDPTR
0011 75F01C            MOV     B,#01CH
0014 A4                MUL     AB
0015 2400        E     ADD     A,#LOW g_Sc8913_Registers+017H
0017 F8                MOV     R0,A
0018 E6                MOV     A,@R0
0019 5F                ANL     A,R7
001A 6003              JZ      ?C0051
                                           ; SOURCE LINE # 208
                                           ; SOURCE LINE # 209
001C 7F01              MOV     R7,#01H
001E 22                RET     
                                           ; SOURCE LINE # 210
001F         ?C0051:
                                           ; SOURCE LINE # 212
                                           ; SOURCE LINE # 213
001F 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 214
                                           ; SOURCE LINE # 215
0021         ?C0052:
0021 22                RET     
             ; FUNCTION _Get_StatusBit (END)

             ; FUNCTION _Set_AcDef (BEGIN)
                                           ; SOURCE LINE # 223
0000 900000      R     MOV     DPTR,#p_ch
0003 120000      R     LCALL   L?0108
                                           ; SOURCE LINE # 224
                                           ; SOURCE LINE # 225
0006 E4                CLR     A
0007 A3                INC     DPTR
0008 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 228
0009 7D06              MOV     R5,#06H
000B 120000      R     LCALL   _Get_StatusBit
000E EF                MOV     A,R7
000F 6024              JZ      ?C0054
                                           ; SOURCE LINE # 229
                                           ; SOURCE LINE # 230
0011 900000      R     MOV     DPTR,#temp
0014 7424              MOV     A,#024H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 231
0017 900000      R     MOV     DPTR,#p_ch
001A 120000      R     LCALL   L?0101
001D 120000      E     LCALL   ?C?CLDPTR
0020 7A00        R     MOV     R2,#HIGH temp
0022 7900        R     MOV     R1,#LOW temp
0024 120000      R     LCALL   L?0105
0027 7D09              MOV     R5,#09H
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 58  

0029 120000      E     LCALL   _Sc8913_Write_Register
002C EF                MOV     A,R7
002D 7003              JNZ     ?C0055
                                           ; SOURCE LINE # 232
                                           ; SOURCE LINE # 233
002F 7F02              MOV     R7,#02H
0031 22                RET     
                                           ; SOURCE LINE # 234
0032         ?C0055:
                                           ; SOURCE LINE # 235
0032 7F01              MOV     R7,#01H
0034 22                RET     
                                           ; SOURCE LINE # 236
0035         ?C0054:
                                           ; SOURCE LINE # 239
                                           ; SOURCE LINE # 240
0035 900000      R     MOV     DPTR,#temp
0038 7404              MOV     A,#04H
003A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 241
003B 900000      R     MOV     DPTR,#p_ch
003E 120000      R     LCALL   L?0101
0041 120000      E     LCALL   ?C?CLDPTR
0044 FF                MOV     R7,A
0045 7B01              MOV     R3,#01H
0047 7A00        R     MOV     R2,#HIGH temp
0049 7900        R     MOV     R1,#LOW temp
004B 120000      R     LCALL   L?0106
004E 7D09              MOV     R5,#09H
0050 120000      E     LCALL   _Sc8913_Write_Register
0053 EF                MOV     A,R7
0054 7003              JNZ     ?C0058
                                           ; SOURCE LINE # 242
                                           ; SOURCE LINE # 243
0056 7F02              MOV     R7,#02H
0058 22                RET     
                                           ; SOURCE LINE # 244
0059         ?C0058:
                                           ; SOURCE LINE # 245
0059 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 246
                                           ; SOURCE LINE # 247
005B         ?C0056:
005B 22                RET     
             ; FUNCTION _Set_AcDef (END)

             ; FUNCTION _Charging_Poll (BEGIN)
                                           ; SOURCE LINE # 255
0000 900000      R     MOV     DPTR,#p_ch
0003 120000      R     LCALL   L?0108
                                           ; SOURCE LINE # 256
                                           ; SOURCE LINE # 258
0006 900000      R     MOV     DPTR,#p_ch
0009 120000      R     LCALL   L?0101
000C 120000      R     LCALL   _Set_AcDef
                                           ; SOURCE LINE # 260
000F 900000      R     MOV     DPTR,#p_ch
0012 120000      R     LCALL   L?0101
0015 120000      R     LCALL   _Get_BAT_Voltage
0018 900000      R     MOV     DPTR,#p_ch
001B 120000      R     LCALL   L?0101
001E 900004            MOV     DPTR,#04H
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 59  

0021 120000      E     LCALL   ?C?LSTOPTR
                                           ; SOURCE LINE # 262
0024 120000      R     LCALL   _Get_BAT_Current
0027 900000      R     MOV     DPTR,#p_ch
002A 120000      R     LCALL   L?0101
002D 900008            MOV     DPTR,#08H
0030 120000      E     LCALL   ?C?LSTOPTR
                                           ; SOURCE LINE # 264
0033 900038            MOV     DPTR,#038H
0036 120000      E     LCALL   ?C?CLDOPTR
0039 7032              JNZ     ?C0059
                                           ; SOURCE LINE # 265
                                           ; SOURCE LINE # 266
003B 900000      R     MOV     DPTR,#p_ch
003E 120000      R     LCALL   L?0101
0041 120000      R     LCALL   _Check_Connect
0044 EF                MOV     A,R7
0045 6401              XRL     A,#01H
0047 900000      R     MOV     DPTR,#p_ch
004A 7016              JNZ     ?C0060
                                           ; SOURCE LINE # 267
                                           ; SOURCE LINE # 268
004C 120000      R     LCALL   L?0101
004F 900038            MOV     DPTR,#038H
0052 7401              MOV     A,#01H
0054 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 269
0057 900039            MOV     DPTR,#039H
005A 7401              MOV     A,#01H
005C 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 270
005F 020000      R     LJMP    _Get_BackCharging_Parameters
                                           ; SOURCE LINE # 271
0062         ?C0060:
                                           ; SOURCE LINE # 273
                                           ; SOURCE LINE # 274
0062 120000      R     LCALL   L?0101
0065 900003            MOV     DPTR,#03H
0068 7404              MOV     A,#04H
006A 020000      E     LJMP    ?C?CSTOPTR
                                           ; SOURCE LINE # 275
                                           ; SOURCE LINE # 276
006D         ?C0059:
                                           ; SOURCE LINE # 279
                                           ; SOURCE LINE # 281
006D 900000      R     MOV     DPTR,#p_ch
0070 120000      R     LCALL   L?0101
0073 120000      R     LCALL   _Get_NowChargingMode
                                           ; SOURCE LINE # 282
0076 900000      R     MOV     DPTR,#p_ch
0079 120000      R     LCALL   L?0101
007C 120000      R     LCALL   _ChargingStage_Monitor
                                           ; SOURCE LINE # 283
                                           ; SOURCE LINE # 284
007F         ?C0063:
007F 22                RET     
             ; FUNCTION _Charging_Poll (END)

             ; FUNCTION _Check_Connect (BEGIN)
                                           ; SOURCE LINE # 292
0000 900000      R     MOV     DPTR,#p_ch
0003 120000      R     LCALL   L?0108
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 60  

                                           ; SOURCE LINE # 293
                                           ; SOURCE LINE # 298
0006 120000      R     LCALL   L?0109
0009 503E              JNC     ?C0064
                                           ; SOURCE LINE # 299
                                           ; SOURCE LINE # 300
000B 900000      R     MOV     DPTR,#p_ch
000E 120000      R     LCALL   L?0101
0011 900001            MOV     DPTR,#01H
0014 E4                CLR     A
0015 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 302
0018 120000      R     LCALL   L?0115
001B E0                MOVX    A,@DPTR
001C 702E              JNZ     ?C0068
                                           ; SOURCE LINE # 303
                                           ; SOURCE LINE # 304
001E 900000      R     MOV     DPTR,#p_ch
0021 120000      R     LCALL   L?0101
0024 120000      R     LCALL   _Set_Charging_Mode
0027 EF                MOV     A,R7
0028 7002              JNZ     ?C0066
                                           ; SOURCE LINE # 305
                                           ; SOURCE LINE # 306
002A FF                MOV     R7,A
002B 22                RET     
                                           ; SOURCE LINE # 307
002C         ?C0066:
                                           ; SOURCE LINE # 309
002C 900000      R     MOV     DPTR,#p_ch
002F 120000      R     LCALL   L?0101
0032 120000      E     LCALL   ?C?CLDPTR
0035 FF                MOV     R7,A
0036 E4                CLR     A
0037 FD                MOV     R5,A
0038 120000      E     LCALL   _Set_Sc8913_Stop
                                           ; SOURCE LINE # 310
003B 900000      R     MOV     DPTR,#p_ch
003E 120000      R     LCALL   L?0101
0041 120000      R     LCALL   L?0115
0044 7401              MOV     A,#01H
0046 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 311
                                           ; SOURCE LINE # 312
0047 8003              SJMP    ?C0068
0049         ?C0064:
                                           ; SOURCE LINE # 314
                                           ; SOURCE LINE # 315
0049 7F00              MOV     R7,#00H
004B 22                RET     
                                           ; SOURCE LINE # 316
004C         ?C0068:
                                           ; SOURCE LINE # 319
004C 900000      R     MOV     DPTR,#p_ch
004F 120000      R     LCALL   L?0101
0052 120000      R     LCALL   L?0117
0055 500E              JNC     ?C0069
                                           ; SOURCE LINE # 320
                                           ; SOURCE LINE # 321
0057 900000      R     MOV     DPTR,#p_ch
005A 120000      R     LCALL   L?0101
005D 120000      R     LCALL   L?0116
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 61  

0060 E4                CLR     A
0061 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 322
0062 7F01              MOV     R7,#01H
0064 22                RET     
                                           ; SOURCE LINE # 323
0065         ?C0069:
                                           ; SOURCE LINE # 326
                                           ; SOURCE LINE # 327
0065 900000      R     MOV     DPTR,#p_ch
0068 120000      R     LCALL   L?0101
006B 120000      E     LCALL   ?C?CLDPTR
006E 120000      R     LCALL   L?0135
0071 E0                MOVX    A,@DPTR
0072 04                INC     A
0073 F0                MOVX    @DPTR,A
0074 C3                CLR     C
0075 9432              SUBB    A,#032H
0077 E4                CLR     A
0078 9400              SUBB    A,#00H
007A 401A              JC      ?C0070
                                           ; SOURCE LINE # 328
                                           ; SOURCE LINE # 329
007C 120000      E     LCALL   ?C?CLDPTR
007F FF                MOV     R7,A
0080 120000      R     LCALL   L?0135
0083 E4                CLR     A
0084 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 331
0085 7D01              MOV     R5,#01H
0087 120000      E     LCALL   _Set_Sc8913_Stop
                                           ; SOURCE LINE # 332
008A 900000      R     MOV     DPTR,#p_ch
008D 120000      R     LCALL   L?0101
0090 120000      R     LCALL   L?0131
                                           ; SOURCE LINE # 333
0093 7F01              MOV     R7,#01H
0095 22                RET     
                                           ; SOURCE LINE # 334
                                           ; SOURCE LINE # 335
0096         ?C0070:
                                           ; SOURCE LINE # 337
0096 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 338
0098         ?C0067:
0098 22                RET     
             ; FUNCTION _Check_Connect (END)

             ; FUNCTION _Get_BackCharging_Parameters (BEGIN)
                                           ; SOURCE LINE # 346
0000 900000      R     MOV     DPTR,#p_ch
0003 120000      R     LCALL   L?0108
                                           ; SOURCE LINE # 347
                                           ; SOURCE LINE # 349
0006 900000      R     MOV     DPTR,#p_ch
0009 120000      R     LCALL   L?0101
000C 120000      R     LCALL   L?0118
000F 7BF5              MOV     R3,#0F5H
0011 7A28              MOV     R2,#028H
0013 793C              MOV     R1,#03CH
0015 120000      R     LCALL   L?0127
0018 120000      R     LCALL   L?0101
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 62  

001B 900018            MOV     DPTR,#018H
001E 120000      E     LCALL   ?C?LSTOPTR
                                           ; SOURCE LINE # 351
0021 900014            MOV     DPTR,#014H
0024 120000      E     LCALL   ?C?LSTKOPTR
0027 3E                DB      03EH
0028 4C                DB      04CH
0029 CC                DB      0CCH
002A CD                DB      0CDH
                                           ; SOURCE LINE # 353
002B 120000      R     LCALL   L?0118
002E 7B45              MOV     R3,#045H
0030 7AB6              MOV     R2,#0B6H
0032 7983              MOV     R1,#083H
0034 120000      R     LCALL   L?0127
0037 120000      R     LCALL   L?0101
003A 900020            MOV     DPTR,#020H
003D 120000      E     LCALL   ?C?LSTOPTR
                                           ; SOURCE LINE # 355
0040 900004            MOV     DPTR,#04H
0043 120000      E     LCALL   ?C?LLDOPTR0
0046 7F66              MOV     R7,#066H
0048 7E66              MOV     R6,#066H
004A 7D06              MOV     R5,#06H
004C 7C41              MOV     R4,#041H
004E 120000      E     LCALL   ?C?FPDIV
0051 900000      R     MOV     DPTR,#p_ch
0054 120000      R     LCALL   L?0101
0057 90001C            MOV     DPTR,#01CH
005A 120000      E     LCALL   ?C?LSTOPTR
                                           ; SOURCE LINE # 357
005D 120000      R     LCALL   L?0119
0060 7B66              MOV     R3,#066H
0062 7A66              MOV     R2,#066H
0064 7986              MOV     R1,#086H
0066 120000      R     LCALL   L?0128
0069 120000      R     LCALL   L?0101
006C 900028            MOV     DPTR,#028H
006F 120000      E     LCALL   ?C?LSTOPTR
                                           ; SOURCE LINE # 359
0072 900024            MOV     DPTR,#024H
0075 120000      E     LCALL   ?C?LSTKOPTR
0078 3E                DB      03EH
0079 99                DB      099H
007A 99                DB      099H
007B 9A                DB      09AH
                                           ; SOURCE LINE # 360
007C 22                RET     
             ; FUNCTION _Get_BackCharging_Parameters (END)

             ; FUNCTION _Get_NowChargingMode (BEGIN)
                                           ; SOURCE LINE # 368
0000 900000      R     MOV     DPTR,#p_ch
0003 120000      R     LCALL   L?0108
                                           ; SOURCE LINE # 369
                                           ; SOURCE LINE # 370
0006 900000      R     MOV     DPTR,#p_ch
0009 120000      R     LCALL   L?0101
000C 120000      R     LCALL   L?0134
000F 6403              XRL     A,#03H
0011 6058              JZ      ?C0074
                                           ; SOURCE LINE # 373
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 63  

0013 120000      R     LCALL   L?0109
0016 600F              JZ      ?C0075
0018 400D              JC      ?C0075
                                           ; SOURCE LINE # 374
                                           ; SOURCE LINE # 375
001A 900000      R     MOV     DPTR,#p_ch
001D 120000      R     LCALL   L?0101
0020 900003            MOV     DPTR,#03H
0023 7404              MOV     A,#04H
                                           ; SOURCE LINE # 376
0025 8041              SJMP    ?C0097
0027         ?C0075:
                                           ; SOURCE LINE # 377
0027 900000      R     MOV     DPTR,#p_ch
002A 120000      R     LCALL   L?0101
002D 900018            MOV     DPTR,#018H
0030 120000      R     LCALL   L?0126
0033 6002              JZ      $ + 4H
0035 500C              JNC     ?C0077
                                           ; SOURCE LINE # 378
                                           ; SOURCE LINE # 379
0037 900000      R     MOV     DPTR,#p_ch
003A 120000      R     LCALL   L?0101
003D 900003            MOV     DPTR,#03H
0040 E4                CLR     A
0041         ?C0095:
                                           ; SOURCE LINE # 380
0041 8025              SJMP    ?C0097
0043         ?C0077:
                                           ; SOURCE LINE # 381
0043 900000      R     MOV     DPTR,#p_ch
0046 120000      R     LCALL   L?0101
0049 900028            MOV     DPTR,#028H
004C 120000      R     LCALL   L?0126
004F 900000      R     MOV     DPTR,#p_ch
0052 6002              JZ      $ + 4H
0054 500A              JNC     ?C0079
                                           ; SOURCE LINE # 382
                                           ; SOURCE LINE # 383
0056 120000      R     LCALL   L?0101
0059 900003            MOV     DPTR,#03H
005C 7401              MOV     A,#01H
005E         ?C0096:
                                           ; SOURCE LINE # 384
005E 8008              SJMP    ?C0097
0060         ?C0079:
                                           ; SOURCE LINE # 386
                                           ; SOURCE LINE # 387
0060 120000      R     LCALL   L?0101
0063 900003            MOV     DPTR,#03H
0066 7402              MOV     A,#02H
0068         ?C0097:
0068 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 388
                                           ; SOURCE LINE # 389
006B         ?C0074:
006B 22                RET     
             ; FUNCTION _Get_NowChargingMode (END)

             ; FUNCTION _ChargingStage_Monitor (BEGIN)
                                           ; SOURCE LINE # 397
0000 900000      R     MOV     DPTR,#p_ch
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 64  

0003 120000      R     LCALL   L?0108
                                           ; SOURCE LINE # 398
                                           ; SOURCE LINE # 400
0006 900000      R     MOV     DPTR,#p_ch
0009 120000      R     LCALL   L?0101
000C 7D01              MOV     R5,#01H
000E 120000      R     LCALL   _Get_StatusBit
0011 EF                MOV     A,R7
0012 6401              XRL     A,#01H
0014 701D              JNZ     ?C0081
                                           ; SOURCE LINE # 401
                                           ; SOURCE LINE # 402
0016 900000      R     MOV     DPTR,#p_ch
0019 120000      R     LCALL   L?0101
001C 120000      R     LCALL   L?0110
001F 5012              JNC     ?C0081
                                           ; SOURCE LINE # 403
                                           ; SOURCE LINE # 404
0021 900000      R     MOV     DPTR,#p_ch
0024 120000      R     LCALL   L?0101
0027 120000      R     LCALL   L?0131
                                           ; SOURCE LINE # 406
002A 120000      E     LCALL   ?C?CLDPTR
002D FF                MOV     R7,A
002E 7D01              MOV     R5,#01H
0030 120000      E     LCALL   _Set_Sc8913_Stop
                                           ; SOURCE LINE # 407
                                           ; SOURCE LINE # 408
0033         ?C0081:
                                           ; SOURCE LINE # 410
0033 900000      R     MOV     DPTR,#p_ch
0036 120000      R     LCALL   L?0101
0039 120000      R     LCALL   _Check_DisConnect
003C EF                MOV     A,R7
003D 6401              XRL     A,#01H
003F 7021              JNZ     ?C0084
                                           ; SOURCE LINE # 411
                                           ; SOURCE LINE # 412
0041 900000      R     MOV     DPTR,#p_ch
0044 120000      R     LCALL   L?0101
0047 900038            MOV     DPTR,#038H
004A E4                CLR     A
004B 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 414
004E 7404              MOV     A,#04H
0050 120000      R     LCALL   L?0132
                                           ; SOURCE LINE # 415
0053 900001            MOV     DPTR,#01H
0056 7402              MOV     A,#02H
0058 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 417
005B 900039            MOV     DPTR,#039H
005E E4                CLR     A
005F 120000      E     LCALL   ?C?CSTOPTR
                                           ; SOURCE LINE # 418
                                           ; SOURCE LINE # 419
0062         ?C0084:
0062 22                RET     
             ; FUNCTION _ChargingStage_Monitor (END)

             ; FUNCTION _Check_DisConnect (BEGIN)
                                           ; SOURCE LINE # 427
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 65  

0000 900000      R     MOV     DPTR,#p_ch
0003 120000      R     LCALL   L?0108
                                           ; SOURCE LINE # 428
                                           ; SOURCE LINE # 429
0006 900000      R     MOV     DPTR,#p_ch
0009 120000      R     LCALL   L?0101
000C 120000      R     LCALL   L?0117
000F 6012              JZ      ?C0085
0011 4010              JC      ?C0085
0013 900000      R     MOV     DPTR,#p_ch
0016 120000      R     LCALL   L?0101
0019 120000      R     LCALL   L?0110
001C 6005              JZ      ?C0085
001E 4003              JC      ?C0085
                                           ; SOURCE LINE # 430
                                           ; SOURCE LINE # 431
0020 7F01              MOV     R7,#01H
0022 22                RET     
                                           ; SOURCE LINE # 432
0023         ?C0085:
                                           ; SOURCE LINE # 434
0023 7F00              MOV     R7,#00H
                                           ; SOURCE LINE # 435
0025         ?C0086:
0025 22                RET     
             ; FUNCTION _Check_DisConnect (END)

             ; FUNCTION _Set_Charging_Amimation (BEGIN)
                                           ; SOURCE LINE # 443
;---- Variable 'state' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 444
                                           ; SOURCE LINE # 445
0000 E4                CLR     A
0001 900000      R     MOV     DPTR,#temp_value
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 447
0007 EF                MOV     A,R7
0008 6401              XRL     A,#01H
000A 7007              JNZ     ?C0087
                                           ; SOURCE LINE # 448
                                           ; SOURCE LINE # 449
000C 900000      R     MOV     DPTR,#temp_value
000F F0                MOVX    @DPTR,A
0010 A3                INC     DPTR
0011 04                INC     A
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 450
0013         ?C0087:
                                           ; SOURCE LINE # 452
0013 900000      R     MOV     DPTR,#addr
0016 7A00        R     MOV     R2,#HIGH temp_value
0018 7900        R     MOV     R1,#LOW temp_value
001A 120000      R     LCALL   L?0111
001D 7402              MOV     A,#02H
001F F0                MOVX    @DPTR,A
0020 020000      E     LJMP    _Dwin_Write
             ; FUNCTION _Set_Charging_Amimation (END)

             ; FUNCTION _Set_Charging_State (BEGIN)
                                           ; SOURCE LINE # 461
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 66  

;---- Variable 'state' assigned to Register 'R7' ----
                                           ; SOURCE LINE # 462
                                           ; SOURCE LINE # 463
0000 900000      R     MOV     DPTR,#temp_value
0003 E4                CLR     A
0004 F0                MOVX    @DPTR,A
0005 A3                INC     DPTR
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 465
0008 900000      R     MOV     DPTR,#addr
000B 7A00        R     MOV     R2,#HIGH temp_value
000D 7900        R     MOV     R1,#LOW temp_value
000F 120000      R     LCALL   L?0111
0012 7402              MOV     A,#02H
0014 F0                MOVX    @DPTR,A
0015 020000      E     LJMP    _Dwin_Write
             ; FUNCTION _Set_Charging_State (END)

C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 67  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


uint16_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
g_Cloud_Buffer . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0007H  48
Constant_Current_Mode. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P0 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0080H  1
Four_Cell. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P1 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0090H  1
Cell . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
R_20m. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
High . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P2 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A0H  1
_Dwin_Write. . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Background_Parameters. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  24
  Trickle_Target_Current . . . . . . .  MEMBER   -----  FLOAT    0000H  4
  Trickle_Target_Voltage . . . . . . .  MEMBER   -----  FLOAT    0004H  4
  ConstantCurrent_Target_Current . . .  MEMBER   -----  FLOAT    0008H  4
  ConstantCurrent_Target_Voltage . . .  MEMBER   -----  FLOAT    000CH  4
  ConstantVoltage_Target_Current . . .  MEMBER   -----  FLOAT    0010H  4
  ConstantVoltage_Target_Voltage . . .  MEMBER   -----  FLOAT    0014H  4
P3 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B0H  1
R_40m. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P4 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C0H  1
Vbat_IRCompensation. . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
P5 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
Vbat_Units . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
One_Cell . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
P6 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00E8H  1
int32_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  LONG     -----  4
P7 . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00F8H  1
g_Charger. . . . . . . . . . . . . . .  PUBLIC   XDATA  ARRAY    0037H  189
R_80m. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Battery_Interval . . . . . . . . . . .  STATIC   XDATA  ARRAY    00F4H  32
Charging_State . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
Write. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
IE . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00A8H  1
Both . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_Check_Connect . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  p_ch . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  mutex. . . . . . . . . . . . . . . .  STATIC   XDATA  ARRAY    0001H  3
  counts . . . . . . . . . . . . . . .  STATIC   XDATA  ARRAY    0004H  3
_Get_BAT_Voltage . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  p_ch . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
VINRANG_SET_Register . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  VINRANG_SET_Type . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  VINRANG_SET_Addr . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  VINRANG_SET. . . . . . . . . . . . .  MEMBER   -----  UNION    0002H  1
STATUS_Register. . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  STATUS_Type. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  STATUS_Addr. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  STATUS . . . . . . . . . . . . . . .  MEMBER   -----  UNION    0002H  1
size_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
IBAT_FB_VALUE_Register . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  IBAT_FB_VALUE_Type . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  IBAT_FB_VALUE_Addr . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  IBAT_FB_VALUE. . . . . . . . . . . .  MEMBER   -----  UNION    0002H  3
IP . . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00B8H  1
_Get_BackCharging_Parameters . . . . .  STATIC   CODE   PROC     0000H  -----
  p_ch . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 68  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


_Set_Charging_State. . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  state. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0007H  1
  addr . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0001H  4
  temp_value . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0005H  2
_Set_Charging_Mode . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  p_ch . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  ret. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0003H  1
  dat. . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0004H  1
Foreground_Parameters. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  16
  Voltage. . . . . . . . . . . . . . .  MEMBER   -----  FLOAT    0000H  4
  Current. . . . . . . . . . . . . . .  MEMBER   -----  FLOAT    0004H  4
  Time . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0008H  4
  Electricity. . . . . . . . . . . . .  MEMBER   -----  FLOAT    000CH  4
Two_Cell . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
pfunc. . . . . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
End_Charging . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_Get_BAT_Current . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  p_ch . . . . . . . . . . . . . . . .  * REG *  DATA   PTR      0001H  3
_Charging_Poll . . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  p_ch . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
VBAT_FB_VALUE_Register . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  VBAT_FB_VALUE_Type . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  VBAT_FB_VALUE_Addr . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  VBAT_FB_VALUE. . . . . . . . . . . .  MEMBER   -----  UNION    0002H  3
_Set_Sc8913_Stop . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
Reg_Type . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
CCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D8H  1
_Sc8913_Write_Register . . . . . . . .  EXTERN   CODE   PROC     -----  -----
VBAT_SET_Register. . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  VBAT_SET_Type. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  VBAT_SET_Addr. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  VBAT_SET . . . . . . . . . . . . . .  MEMBER   -----  UNION    0002H  1
IBUS_FB_VALUE_Register . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  IBUS_FB_VALUE_Type . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  IBUS_FB_VALUE_Addr . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  IBUS_FB_VALUE. . . . . . . . . . . .  MEMBER   -----  UNION    0002H  3
_Get_StatusBit . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  p_ch . . . . . . . . . . . . . . . .  * REG *  DATA   PTR      0001H  3
  abit . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  site . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0007H  1
RATIO_Register . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  RATIO_Type . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  RATIO_Addr . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  RATIO. . . . . . . . . . . . . . . .  MEMBER   -----  UNION    0002H  1
_Report_ChargerInfo. . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  p_ch . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  Report . . . . . . . . . . . . . . .  AUTO     XDATA  STRUCT   0003H  16
  back_addr. . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0013H  2
  param_addr . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0015H  2
  temp_buf . . . . . . . . . . . . . .  AUTO     XDATA  ARRAY    0017H  56
  i. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
  counter. . . . . . . . . . . . . . .  STATIC   XDATA  U_CHAR   0000H  1
External_Mode. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_Check_DisConnect. . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  p_ch . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
_Get_Battery_Range . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  persent_voltage. . . . . . . . . . .  AUTO     XDATA  FLOAT    0000H  4
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 69  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  length . . . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0004H  2
  i. . . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0006H  1
Low. . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
DwinMap. . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  7
  addr . . . . . . . . . . . . . . . .  MEMBER   -----  U_LONG   0000H  4
  event. . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0004H  3
SCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
VBUS_FB_VALUE_Register . . . . . . . .  TYPEDEF  -----  STRUCT   -----  5
  VBUS_FB_VALUE_Type . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  VBUS_FB_VALUE_Addr . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  VBUS_FB_VALUE. . . . . . . . . . . .  MEMBER   -----  UNION    0002H  3
TCON . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0088H  1
Trickle_Mode . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_Set_Charging_Amimation. . . . . . . .  STATIC   CODE   PROC     0000H  -----
  state. . . . . . . . . . . . . . . .  AUTO     DATA   U_CHAR   0007H  1
  addr . . . . . . . . . . . . . . . .  AUTO     XDATA  U_LONG   0001H  4
  temp_value . . . . . . . . . . . . .  AUTO     XDATA  U_INT    0005H  2
Vbat_Units_Voltage . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
VBUSREF_I_SET_Register . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  VBUSREF_I_SET_Type . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  VBUSREF_I_SET_Addr . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  VBUSREF_I_SET. . . . . . . . . . . .  MEMBER   -----  UNION    0002H  1
_?ix1000 . . . . . . . . . . . . . . .  STATIC   CODE   STRUCT   0000H  16
_Set_AcDef . . . . . . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  p_ch . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
  temp . . . . . . . . . . . . . . . .  AUTO     XDATA  U_CHAR   0003H  1
IIC_Pin_State. . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
_?ix1001 . . . . . . . . . . . . . . .  STATIC   CODE   ARRAY    0010H  56
Inside_Mode. . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Dwin_T . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  260
  RxBuf. . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  128
  RxCount. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0080H  2
  TxBuf. . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0082H  128
  TxCount. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0102H  2
V4_10. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
V4_20. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
V4_30. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
V4_40. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
V4_50. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
R_0m . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
uint8_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
V4_25. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
V4_35. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
V4_45. . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
stdantby_Mode. . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
__IO . . . . . . . . . . . . . . . . .  TYPEDEF  -----  INT      -----  2
Device_Type. . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
MASK_Register. . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  MASK_Type. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  MASK_Addr. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  MASK . . . . . . . . . . . . . . . .  MEMBER   -----  UNION    0002H  1
int8_t . . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
IBAT_LIM_SET_Register. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  IBAT_LIM_SET_Type. . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  IBAT_LIM_SET_Addr. . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  IBAT_LIM_SET . . . . . . . . . . . .  MEMBER   -----  UNION    0002H  1
Three_Cell . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 70  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


Charging_Typedef . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  63
  Channel_Id . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  Dev_Type . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  Batterry_Numbers . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  CState . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  For_ChargingPara . . . . . . . . . .  MEMBER   -----  STRUCT   0004H  16
  Bac_ChargingPara . . . . . . . . . .  MEMBER   -----  STRUCT   0014H  24
  Charger_Show_Addr. . . . . . . . . .  MEMBER   -----  STRUCT   002CH  12
  Charger_Flag . . . . . . . . . . . .  MEMBER   -----  STRUCT   0038H  3
  Vbat_Ratio . . . . . . . . . . . . .  MEMBER   -----  FLOAT    003BH  4
CTRL0_SET_Register . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  CTRL0_SET_Type . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  CTRL0_SET_Addr . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  CTRL0_SET. . . . . . . . . . . . . .  MEMBER   -----  UNION    0002H  1
CTRL1_SET_Register . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  CTRL1_SET_Type . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  CTRL1_SET_Addr . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  CTRL1_SET. . . . . . . . . . . . . .  MEMBER   -----  UNION    0002H  1
CTRL2_SET_Register . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  CTRL2_SET_Type . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  CTRL2_SET_Addr . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  CTRL2_SET. . . . . . . . . . . . . .  MEMBER   -----  UNION    0002H  1
CTRL3_SET_Register . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  CTRL3_SET_Type . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  CTRL3_SET_Addr . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  CTRL3_SET. . . . . . . . . . . . . .  MEMBER   -----  UNION    0002H  1
_Get_NowChargingMode . . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  p_ch . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
MODS_T . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  262
  RxBuf. . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0000H  128
  RxCount. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0080H  2
  RxStatus . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0082H  1
  RxNewFlag. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0083H  1
  TxBuf. . . . . . . . . . . . . . . .  MEMBER   -----  ARRAY    0084H  128
  TxCount. . . . . . . . . . . . . . .  MEMBER   -----  U_INT    0104H  2
wchar_t. . . . . . . . . . . . . . . .  TYPEDEF  -----  CHAR     -----  1
_ChargingStage_Monitor . . . . . . . .  STATIC   CODE   PROC     0000H  -----
  p_ch . . . . . . . . . . . . . . . .  AUTO     XDATA  PTR      0000H  3
Channel0 . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Constant_Voltage_Mode. . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Channel1 . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Dcdc . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
Channel2 . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
IBUS_LIM_SET_Register. . . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  IBUS_LIM_SET_Type. . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  IBUS_LIM_SET_Addr. . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  IBUS_LIM_SET . . . . . . . . . . . .  MEMBER   -----  UNION    0002H  1
No_Device. . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1
_MOD_46H . . . . . . . . . . . . . . .  EXTERN   CODE   PROC     -----  -----
g_Sc8913_Registers . . . . . . . . . .  EXTERN   DATA   ARRAY    -----  84
IIC_Channel. . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
VBUSREF_I_SET2_Register. . . . . . . .  TYPEDEF  -----  STRUCT   -----  3
  VBUSREF_I_SET2_Type. . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  VBUSREF_I_SET2_Addr. . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  VBUSREF_I_SET2 . . . . . . . . . . .  MEMBER   -----  UNION    0002H  1
Vbat_Mode. . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
va_list. . . . . . . . . . . . . . . .  TYPEDEF  -----  PTR      -----  3
C51 COMPILER V9.60.0.0   CHARGER                                                           01/05/2022 14:26:36 PAGE 71  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


PSW. . . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00D0H  1
uint32_t . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
Read . . . . . . . . . . . . . . . . .  E_CONST  -----  U_CHAR   -----  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2132    ----
   CONSTANT SIZE    =     72    ----
   XDATA SIZE       =    276     130
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
